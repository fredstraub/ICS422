# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67)
plot(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67, aging.bin = 1000)
plot(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
plot(HEP.age.p10)
plot(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE)
# Plot in-degree distribution with linear binning
plot_pl_distribution <- function(g, title, mode="all",
geodesic=FALSE, cex=1.0) {
#
# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67, aging.bin = 1000)
plot(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
# Plot in-degree distribution with linear binning
plot_pl_distribution <- function(g, title, mode="all",
geodesic=FALSE, cex=1.0) {
#
# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67)
plot(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
# Plot in-degree distribution with linear binning
plot_pl_distribution <- function(g, title, mode="all",
geodesic=FALSE, cex=1.0) {
#
# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67)
plot_pl_distribution(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
# Add a legend with k-min and k-max
# Plot cumulative in-degree distribution
# Add a legend with fit_power_law parameters xmin, alpha, KS.p and KS.stat
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# For including images of these types
library(jpeg)
library(png)
# Utility for plotting degree distributions
source("Utility/degree_domain.R")
par(mfrow=c(1,1))
PG <- read_graph("Networks/power_grid.gml", format="gml")
summary(PG)
include_graphics("power-grid-degree.png")
include_graphics("power-grid-closeup.png")
PG.config <- sample_degseq(degree(PG), method = "vl")
?mean(degree)
# Mean Degree and log(|V|) is the same for both networks, so we
# only need one table. I recommend using tibble.
models <- list(PG, PG.config)
mnames <- c("Power-Grid", "Config")
PG.metrics <- tibble(
Model   = mnames,
V       = sapply(models, vcount),
E       = sapply(models, ecount),
)
PG.metrics
# Display global transitivity, degree correlation, and mean distance
# in a table with each row labeled. You can make a tibble for each row,
# and then combine them with add_row for display.
PG.metrics2 <- tibble(
Model        = mnames,
transitivity = sapply(models, transitivity, type="global")
)
PG.metrics3 <- tibble(
Model        = mnames,
degreeassort = sapply(models, assortativity_degree)
)
PG.metrics4 <- tibble(
Model    = mnames,
meandist = sapply(models, mean_distance)
)
PG.metrics2 <- PG.metrics %>% add_column(transitivity = sapply(models, transitivity, type="global")) %>% add_column(degreeassort = sapply(models, assortativity_degree)) %>% add_column(meandist = sapply(models, mean_distance))
PG.metrics2
# Frequency table of component sizes (no tibble needed, just use table)
count_components(PG)
# Plot degree distribution with linear binning
# Include legend with k-min and k-max
plot(degree_domain(PG), degree_distribution(PG), main="Power-Grid Degree Distribution Log Log", xlab="k", ylab="p(k)", log ="xy")
# Plot cumulative degree distribution
plot(degree_domain(PG), degree_distribution(PG, cumulative = TRUE), main = "Power-Grid Cumulative Degree Distribution Log Log", xlab = "k", ylab = "CDF p(k)", log = "xy")
# Display table (tibble) with fit_power_law results from the plfit method.
as_tibble(PG.plfit <- fit_power_law(degree(PG), implementation = "plfit"))
# try to cover more of the data.
as_tibble(PG.plfit <- fit_power_law(degree(PG), implementation = "plfit", xmin = 1))
PG_gnm <- sample_gnm(vcount(PG), ecount(PG))
round(mean(degree(PG)), 1)
round(mean(degree(PG.config)), 1)
HEP <- read_graph("Networks/cit-HepTh.gml", format="gml")
summary(HEP)
# Plot in-degree distribution with linear binning
plot(degree_domain(HEP, mode="in"), degree_distribution(HEP, mode="in"), log="xy", xlab = "k", ylab = "p(k)", main = "In-Degree Distribution HEP")
# Add a legend with k-min and k-max
plfit_legend <- function(g) {
g.plfit <- fit_power_law(degree(g), implementation="plfit")
legend("bottomleft", bty="n", cex=1.2,
c(paste("kmin =", min(degree(g))),
paste("kmax =", max(degree(g)))))}
plfit_legend(HEP)
# Plot cumulative in-degree distribution
plot(degree_domain(HEP, mode="in"), degree_distribution(HEP, mode="in", cumulative = TRUE), log="xy", xlab = "k", ylab = "p(k)", main = "In-Degree Cumulative Distribution HEP")
# Add a legend with fit_power_law parameters xmin, alpha, KS.p and KS.stat
plfit_legend <- function(g) {
g.plfit <- fit_power_law(degree(g), implementation="plfit")
legend("bottomleft", bty="n", cex=1.2,
c(paste("xmin =", g.plfit$xmin),
paste("alpha = ", round(g.plfit$alpha, digits=2)),
paste("KS p = ", round(g.plfit$KS.p, digits=3)),
paste("KS.stat = ", round(g.plfit$KS.stat, digits=3))))}
plfit_legend(HEP)
# Plot out-degree distribution with linear binning
plot(degree_domain(HEP, mode="out"), degree_distribution(HEP, mode="out"), log="xy", xlab = "k", ylab = "p(k)", main = "Out-Degree Distribution HEP")
# Add a legend with k-min and k-max
plfit_legend <- function(g) {
g.plfit <- fit_power_law(degree(g), implementation="plfit")
legend("bottomleft", bty="n", cex=1.2,
c(paste("kmin =", min(degree(g))),
paste("kmax =", max(degree(g)))))}
plfit_legend(HEP)
# Plot cumulative out-degree distribution
plot(degree_domain(HEP, mode="out"), degree_distribution(HEP, mode="out", cumulative = TRUE), log="xy", xlab = "k", ylab = "p(k)", main = "Out-Degree Cumulative Distribution HEP")
# Add a legend with fit_power_law parameters xmin, alpha, KS.p and KS.stat
plfit_legend <- function(g) {
g.plfit <- fit_power_law(degree(g), implementation="plfit")
legend("bottomleft", bty="n", cex=1.2,
c(paste("xmin =", g.plfit$xmin),
paste("alpha = ", round(g.plfit$alpha, digits=2)),
paste("KS p = ", round(g.plfit$KS.p, digits=3)),
paste("KS.stat = ", round(g.plfit$KS.stat, digits=3))))}
plfit_legend(HEP)
# Provide the sample_pa_age code that generates your best model.
# Print a table of parameters m, attachment preference, initial
# attractiveness, and aging. Again, tibbles make nice output.
# Plot in-degree distribution with linear binning
plot_pl_distribution <- function(g, title, mode="all",
geodesic=FALSE, cex=1.0) {
#
# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67)
plot_pl_distribution(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
# Plot in-degree distribution with linear binning
plot_pl_distribution <- function(g, title, mode="all",
geodesic=FALSE, cex=1.0) {
#
# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67)
plot_pl_distribution(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=1.0)
# Add a legend with k-min and k-max
# Plot cumulative in-degree distribution
# Add a legend with fit_power_law parameters xmin, alpha, KS.p and KS.stat
library(igraph)
library(tibble)
setwd("/Users/frederickstraub/GitHub/ICS422/R-Files") # Set to yours
source("Utility/new_window.R")
source("Utility/degree_domain.R")
plot_assortativity_rewiring <- function(name, source, rewired) {
source.knn <- knn(source, weights=NA)
rewire.knn <- knn(rewired, weights=NA)
plot(source.knn$knnk, log="xy",
main=paste(name, "knn(k)"), xlab="k", ylab="knn(k)")
legend("bottomleft", bty="n", cex=1.2,
c(paste0("r = ",
round(assortativity_degree(source, directed=FALSE),
digits=4))))
plot(rewire.knn$knnk, log="xy",
main=paste(name, "Rewired knn(k)"), xlab="k", ylab="knn(k)")
legend("bottomleft", bty="n", cex=1.2,
c(paste0("r = ",
round(assortativity_degree(rewired, directed=FALSE),
digits=4))))
}
NS <- read_graph("Networks/netscience.graphml", format="graphml")
summary(NS)
assortativity_degree(NS)
f <- 1000
NS.rewired <- rewire(NS, with = keeping_degseq(niter = ecount(NS) * f))
assortativity_degree(NS.rewired)
assortativity_degree(NS)
plot_assortativity_rewiring("Network Science", NS, NS.rewired)
HEP <- read_graph("Networks/cit-HepTh.gml", format="gml")
is_simple(HEP)
HEP.simp <- simplify(HEP)
summary(HEP)
summary(HEP.simp)
ecount(HEP) - ecount(HEP.simp) # insignificant
data.frame(
Directed = c(assortativity_degree(HEP, directed=TRUE),
assortativity_degree(HEP.simp, directed=TRUE)),
Undirected = c(assortativity_degree(HEP, directed=FALSE),
assortativity_degree(HEP.simp, directed=FALSE)),
row.names = c("Original", "Simplified")
)
HEP.simp.rewired <- rewire(HEP.simp,
with = keeping_degseq(niter = ecount(HEP)*100))
plot_assortativity_rewiring <- function(name, source, rewired,
mode="all", nmode="all",
directed=FALSE, weights=NA) {
source.knn <- knn(source, weights=weights, mode=mode,
neighbor.degree.mode=nmode)
rewire.knn <- knn(rewired, weights=weights, mode=mode,
neighbor.degree.mode=nmode)
plot(source.knn$knnk, log="xy",
main=paste(name, "knn(k)"), xlab="k",
ylab=paste0("knn(k), mode=", mode))
# Linear correlation between degree k and knn
legend("bottomleft", bty="n", cex=1.2,
c(as.character(round(cor.test(degree(source,mode=mode),
source.knn$knn)$estimate,
digits=4))))
plot(rewire.knn$knnk, log="xy",
main=paste(name, "Rewired knn(k)"), xlab="k",
ylab=paste0("knn(k), mode=", mode))
legend("bottomleft", bty="n", cex=1.2,
c(as.character(round(cor.test(degree(rewired,mode=mode),
rewire.knn$knn)$estimate,
digits=4))))
}
?cor.test
new_window(title="HEP Deg Dist", width=12, height=6)
par(mfrow=c(1,2))
plot(degree_domain(HEP, mode="in"),
degree_distribution(HEP, mode="in"),
log="xy", main="HEP IN degree distribution")
plot(degree_domain(HEP, mode="out"),
degree_distribution(HEP, mode="out"),
log="xy", main="HEP OUT degree distribution")
new_window(title="HEP knn(k) ALL-ALL", width=12, height=6)
par(mfrow=c(1,2))
plot_assortativity_rewiring("HEP Citations ALL-ALL", HEP.simp,
HEP.simp.rewired, directed=TRUE)
new_window(title="HEP knn(k) IN-IN", width=12, height=6)
par(mfrow=c(1,2))
plot_assortativity_rewiring("HEP Citations IN-IN", HEP.simp,
HEP.simp.rewired, directed=TRUE,
mode="in", nmode="in")
new_window(title="HEP knn(k) OUT-OUT", width=12, height=6)
par(mfrow=c(1,2))
plot_assortativity_rewiring("HEP Citations OUT-OUT", HEP.simp,
HEP.simp.rewired, directed=TRUE,
mode="out", nmode="out")
new_window(title="HEP knn(k) IN-OUT", width=12, height=6)
par(mfrow=c(1,2))
plot_assortativity_rewiring("HEP Citations IN-OUT", HEP.simp,
HEP.simp.rewired, directed=TRUE,
mode="in", nmode="out")
new_window(title="HEP knn(k) OUT-IN", width=12, height=6)
par(mfrow=c(1,2))
plot_assortativity_rewiring("HEP Citations OUT-IN", HEP.simp,
HEP.simp.rewired, directed=TRUE,
mode="out", nmode="in")
