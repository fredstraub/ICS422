# ***** To get started, click on the triangle above right *****
# ***** to run the "r setup" for this document.           *****
require("knitr")
opts_chunk$set(echo = TRUE) # make code available by default
library(igraph)
library(tibble) # for nice tables
# Used to include images
library(jpeg)
library(png)
# Utilities for plotting degree distributions
source("Utility/degree_domain.R")
source("Utility/nonzero_degree_distribution.R")
dir("Networks")
LM <- read_graph("Networks/Les-Miserables.graphml", format="graphml")
summary(LM)
plot(LM, main = "Les-Miserables Co-Appearance",
vertex.size = 10,
vertex.color = "white",
vertex.label.cex = 0.4)
plot(LM, main = "Les-Miserables Co-Appearance",
vertex.size = 10,
vertex.color = "white",
vertex.label.cex = 0.4)
LM <- read_graph("Networks/Les-Miserables.graphml", format="graphml")
summary(LM)
plot(degree_domain(LM),
nonzero_degree_distribution(LM),
main="Les-Miserables Degree Distribution",
xlab="k", ylab="p(k)")
num_partners <- tibble(character=V(LM)$label, partners=degree(LM)) # make the table
num_partners[order(num_partners$partners, decreasing=TRUE),]       # sort by degree
include_graphics("Images/LeMis-Trial.jpg")
include_graphics("Images/LeMis-Preview.jpg")
plot(degree_domain(LM),
nonzero_degree_distribution(LM),
main="Les-Miserables Degree Distribution",
xlab="k", ylab="p(k)")
num_partners <- tibble(character=V(LM)$label, partners=degree(LM)) # make the table
num_partners[order(num_partners$partners, decreasing=TRUE),]       # sort by degree
---
title: "Lastname Analysis 1 Visualization"
author: "Fred Straub"
date: "2/3/2022"
output:
html_notebook:
code_folding: hide
df_print: paged
html_document:
code_folding: hide
df_print: paged
---
```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(jpeg) # Optional, for including images of these types
library(png)
include_graphics("Q1actor_type.png")
include_graphics("Q1countries.png")
include_graphics("Q1actor_type.png")
*I Used Forced Atlas 2 for the original grouping of nodes by country.  I adjusted the Repulsion up and the Gravity upwards.  I did not like th result of t prevent overlap or LinLog.I sized the nodes by the degree attribute and first colored them by country.  I removed the Label column and then relabeled one of each country as I noticed they were grouping fairly separately.  I then changed the node colors to correspond to the actor_type.  I noticed that there was no grouping rather the disciplines were scattered among the countries.*
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(jpeg) # Optional, for including images of these types
library(png)
summary(TI)
TI <- read_graph("Networks/TI-Partition-63.graphml", format="graphml")
summary(TI)
filter(TI, entity = "ACTOR")
filter(TI, entity == "ACTOR")
TIfilterd <- filter(TI, grepl("ACTOR", entity))
V(TI)$entity=V(TI)$entity2
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(jpeg) # Optional, for including images of these types
library(png)
# Code to solve problem and do the projection here
# summary(__projections___)
TI <- read_graph("Networks/TI-Partition-63.graphml", format="graphml")
summary(TI)
V(TI)$actor
V(TI)$entity == actor
V(TI)$entity == ACTOR
V(TI)$entity == $ACTOR
V(TI)$entity == V(TI)$ACTOR
V(TI)$entity == ACTOR
V(TI)$entity == ACTOR
V(TI)$entity == V(TI)$ACTOR
V(TI)$entity == V(TI)$ACTOR
V(TI)$ACTOR
V(TI)$entity
V(TI)$entity == V(TI)$actor
V(TI)$entity == "ACTOR"
# Code to solve problem and do the projection here
# summary(__projections___)
actor2 <- TI(V(TI)$entity == "ACTOR")
# Code to solve problem and do the projection here
# summary(__projections___)
actor2 <- c(V(TI)$entity == "ACTOR")
# Code to solve problem and do the projection here
# summary(__projections___)
actor2 <- c(V(TI)$entity == "ACTOR")
TI2 <- TI
TI2$new_col <- actor2
summary(TI2)
plot(TI, layout = layout_as_bipartite(TI))
plot(TI2, layout = layout_as_bipartite(TI2))
summary(TI2)
summary(TI2)
V(TI2)old_entity
V(TI2)$old_entity
V(TI2)$old_entity = V(TI2)$entity
plot(TI2, layout = layout_as_bipartite(TI2))
V(TI2)$old_entity
summary(TI2)
V(TI2)$entity = V(TI2)$new_col
plot(TI2, layout = layout_as_bipartite(TI2))
summary(TI2)
V(TI2)$entity = V(TI2)$new_col
TI2$new_col <- actor2
summary(TI2)
V(TI2)$old_entity
V(TI2)$old_entity = V(TI2)$entity
summary(TI2)
V(TI2)$entity = V(TI2)$new_col
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(jpeg) # Optional, for including images of these types
library(png)
TI <- read_graph("Networks/TI-Partition-63.graphml", format="graphml")
summary(TI)
# Code to solve problem and do the projection here
# summary(__projections___)
V(TI)$old_entity
V(TI)$old_entity = V(TI2)$entity
V(TI)$old_entity = V(TI)$entity
V(TI)$entity <- c(V(TI)$old_entity == "ACTOR")
plot(TI2, layout = layout_as_bipartite(TI2))
old_entity
set_vertex_attr("room_type", value = V(TI)$type)
V(TI)$entity <- c(V(TI)$old_entity == "ACTOR")
set_vertex_attr("room_type", value = V(TI)$type)
plot(TI2, layout = layout_as_bipartite(TI2))
# Code to solve problem and do the projection here
# summary(__projections___)
V(TI)$old_entity
V(TI)$entity
V(TI)$type
plot(TI2, layout = layout_as_bipartite(TI2))
V(TI)$entity
V(TI)$actors
V(TI)$actors
V(TI)$ACTORS
V(TI)$actor
plot(TI, layout = layout_as_bipartite(TI2))
plot(TI, layout = layout_as_bipartite(TI))
V(TI)$actor <- V(TI)$entity
plot(TI, layout = layout_as_bipartite(TI))
summary(TI)
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(jpeg) # Optional, for including images of these types
library(png)
TI <- read_graph("Networks/TI-Partition-63.graphml", format="graphml")
summary(TI)
# Code to solve problem and do the projection here
# summary(__projections___)
#V(TI)$old_entity
V(TI)$old_entity = V(TI)$entity
summary(TI)
V(TI)$old_entity
V(TI)$acto
V(TI)$actor
V(TI)$entity
V(TI)$actor
V(TI)$entity
V(TI)$entity <- c(V(TI)$entity == "ACTOR")
V(TI)$entity
plot(TI, layout = layout_as_bipartite(TI))
plot(TI, layout = layout_as_bipartite(TI, types = entity))
plot(TI, layout = layout_as_bipartite(TI, types = $entity))
# Code to solve problem and do the projection here
# summary(__projections___)
#V(TI)$old_entity
V(TI)$old_type = V(TI)$type
summary(TI)
V(TI)$old_type
V(TI)$actor
V(TI)$type
V(TI)$type <- c(V(TI)$entity == "ACTOR")
V(TI)$type
plot(TI, layout = layout_as_bipartite(TI))
TI.proj <- bipartite_projection(TI)
TI.proj
```{r}
# write_graph(TI, "TappedIn.graphml", format"graphml")
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(jpeg) # Optional, for including images of these types
library(png)
include_graphics("Q1countries.png")
include_graphics("Q1actor_type.png")
include_graphics("Q2redgreen.png")
include_graphics("Q2alledges.png")
include_graphics("Q2majoredges.png")
TI <- read_graph("Networks/TI-Partition-63.graphml", format="graphml")
summary(TI)
# Code to solve problem and do the projection here
# summary(__projections___)
#V(TI)$old_entity
V(TI)$old_type = V(TI)$type
summary(TI)
V(TI)$old_type
V(TI)$actor
V(TI)$type
V(TI)$type <- c(V(TI)$entity == "ACTOR")
V(TI)$type
plot(TI, layout = layout_as_bipartite(TI))
# write_graph(TI, "TappedIn.graphml", format"graphml")
```{r}
# write_graph(TI, "TappedIn.graphml", format"graphml")
##### (c, 5 pts) Visualize the result in Gephi
The Gephi visualizations may be found in: *(PDF file names)*
*Conclusions drawn about the affiliation of actors and their interactions:*
write_graph(TI, "TappedIn.graphml", format"graphml")
write_graph(TI, "TappedIn.graphml", format="graphml")
ESWA <- read_graph("EuroSiS-webAtlas.graphml", format="graphml")
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(jpeg) # Optional, for including images of these types
library(png)
ESWA <- read_graph("EuroSiS-webAtlas.graphml", format="graphml")
ESWA <- read_graph("network/EuroSiS-webAtlas.graphml", format="graphml")
ESWA <- read_graph("Networks/EuroSiS-webAtlas.graphml", format="graphml")
summary(ESWA)
sort(unique(V(ESWA)$country))
plot(ESWA, ...)
plot(ESWA)
library(igraph)
library(igraph)
setwd("/Users/frederickstraub/GitHub/ICS422/R-Files") # Set to your location
NS <- read_graph("Networks/netscience.graphml", format="graphml")
NS <- read_graph("Networks/netscience.graphml", format="graphml")
JC <- read_graph("Networks/java-classes.graphml", format="graphml")
JC <- read_graph("Networks/java-classes.graphml", format="graphml")
TI <- read_graph("Networks/TappedInChatSampleAnnotated.graphml",
format="graphml")
?mean_distance # ICS students, note the algorithms you studied in 311!
mean_distance(NS)
mean_distance(JC)
mean_distance(JC, directed=FALSE)
diameter(NS)
diameter(JC)
diameter(TI)
head(distances(TI), 1) # just the first start vertex!
count_components(NS)
count_components(JC)
is_connected(JC, mode="weak")
is_connected(JC, mode="weak")
count_components(JC, mode="weak")   # WCC
is_connected(JC, mode="strong")
count_components(JC, mode="strong") # SCC
NS.cd <- component_distribution(NS)
head(NS.cd)
table(NS.cd)
plot(NS.cd,
main="Network Science Component Sizes v1",
xlab="Nc", ylab="p(Nc)")
plot(ifelse(NS.cd==0, NA, NS.cd),
main="Network Science Component Sizes v2",
xlab="Nc", ylab="p(Nc)")
plot(ifelse(NS.cd==0, NA, NS.cd),
main="Network Science Component Sizes v3",
xlab="Nc", ylab="p(Nc)",
log="xy")
plot(0:(length(NS.cd)-1),
ifelse(NS.cd==0, NA, NS.cd),
main="Network Science Component Sizes v4",
xlab="Nc", ylab="p(Nc)",
log="xy")
NS.c <- components(NS)
names(NS.c)
JC.c <- components(JC, mode="strong")
table(NS.c$csize)
table(JC.c$csize)
transitivity(TI)
?transitivity
transitivity(TI)
transitivity(TI, type="average")
transitivity(TI, type="global")
head(transitivity(TI, type="local"), 10)
head(degree(TI), 10)
transitivity(NS, type="average")
transitivity(NS, type="global")
transitivity(JC, type="average")
transitivity(JC, type="global")
plot(degree(NS), transitivity(NS, type="local"), main="NS degree vs CC")
plot(degree(NS), transitivity(NS, type="local"), main="NS degree vs CC")
plot(degree(JC), transitivity(JC, type="local"), main="JC degree vs CC")
JC.und <- as.undirected(JC)
plot(degree(JC.und), transitivity(JC.und, type="local"),
main="JC Undirected degree vs CC")
plot(degree(JC.und), transitivity(JC.und, type="local"),
main="JC Undirected degree vs CC", log="xy")
V(JC)$local_cc <- transitivity(JC, type="local")
V(NS)$local_cc <- transitivity(NS, type="local")
summary(NS)
head(V(NS)$local_cc)
summary(JC)
head(V(JC)$local_cc)
write_graph(JC, "java-classes_with_cc.graphml", format="graphml")
write_graph(NS, "netscience_with_cc.graphml", format="graphml")
assortativity_degree(NS)
assortativity_degree(JC)
?assortativity_degree
