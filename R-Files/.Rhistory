crossing(Heroes.infomap, Heroes)[1:20]
length(which(crossing(Heroes.infomap, Heroes)))[1:20]
length(which(crossing(Heroes.infomap, Heroes)))
# Display the top 20 crossing vertices and the number of edges via
# which they connect to others outside their partition, for both
# Louvain and Infomap. I suggest taking these steps
which(crossing(Heroes.infomap, Heroes))
sort(unique(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label))
sort(unique(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label)), decreasing= TRUE
sort(unique(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing= TRUE)
sort(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes))]$label), decreasing= TRUE)
(unique
sort(unique(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing= TRUE)
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(unique(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:20]
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(unique(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = FALSE)[1:20]
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = FALSE)[1:20]
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:20]
which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:20]
which(crossing(Heroes.louvain, Heroes]$label), decreasing = TRUE)[1:20]
sort(which(crossing(Heroes.louvain, Heroes))$label)
# Display the top 20 crossing vertices and the number of edges via
# which they connect to others outside their partition, for both
# Louvain and Infomap. I suggest taking these steps
which(crossing(Heroes.infomap, Heroes))
length(which(crossing(Heroes.infomap, Heroes)))
# Display the top 20 crossing vertices and the number of edges via
# which they connect to others outside their partition, for both
# Louvain and Infomap. I suggest taking these steps
sort(which(crossing(Heroes.infomap, Heroes)), decreasing = TRUE)
# Display the top 20 crossing vertices and the number of edges via
# which they connect to others outside their partition, for both
# Louvain and Infomap. I suggest taking these steps
sort(which(crossing(Heroes.infomap, Heroes)), decreasing = TRUE)[1:20]
sort(which(crossing(Heroes.louvain, Heroes))$label, decreasing= TRUE)
head(V(Heroes)[ends(Heroes, which(crossing((Heroes.louvain, Heroes))))]$label)
head(V(Heroes)[ends(Heroes, which(crossing((Heroes.louvain, Heroes))))]$label)
head(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label)
sort(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label)
sort((V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)
sort(unique(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing= TRUE)
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:20]
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(which(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:20]
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(unique(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:20]
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:20]
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:1]
# Compute crossings for Louvain, sorted decreasing by crossing:
sort([ends(Heroes, which(crossing(Heroes.louvain, Heroes)]$label), decreasing = TRUE)[1:1]
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(ends(Heroes, which(crossing(Heroes.louvain, Heroes)$label)), decreasing = TRUE)[1:1]
t
t
:20
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:20]
# Display the top 20 crossing vertices and the number of edges via
# which they connect to others outside their partition, for both
# Louvain and Infomap. I suggest taking these steps
sort(which(crossing(Heroes.infomap, Heroes)), decreasing = TRUE)[1:20]
# Display the top 20 crossing vertices and the number of edges via
# which they connect to others outside their partition, for both
# Louvain and Infomap. I suggest taking these steps
crossing(Heroes.infomap, Heroes)
# Display the top 20 crossing vertices and the number of edges via
# which they connect to others outside their partition, for both
# Louvain and Infomap. I suggest taking these steps
length(which(crossing(Heroes.infomap, Heroes))
# Display the top 20 crossing vertices and the number of edges via
# which they connect to others outside their partition, for both
# Louvain and Infomap. I suggest taking these steps
length(which(crossing(Heroes.infomap, Heroes))
# Display the top 20 crossing vertices and the number of edges via
# which they connect to others outside their partition, for both
# Louvain and Infomap. I suggest taking these steps
length(which(crossing(Heroes.infomap, Heroes)))
# Display in combined tibble:
tibble(Hero_in_Louvain = head(ends(Heroes, which(crossing(Heroes.louvain, Heroes))))[1:1],
Cross_Count_L   = length(which(crossing(Heroes.louvain, Heroes))),
Hero_in_Infomap = head(ends(Heroes, which(crossing(Heroes.infomap, Heroes))))[1:1],
Cross_Count_I   = length(which(crossing(Heroes.infomap, Heroes)))
)
# Display in combined tibble:
tibble(Hero_in_Louvain = head(ends(Heroes, which(crossing(Heroes.louvain, Heroes)$label)))[1:1],
Cross_Count_L   = length(which(crossing(Heroes.louvain, Heroes))),
Hero_in_Infomap = head(ends(Heroes, which(crossing(Heroes.infomap, Heroes))))[1:1],
Cross_Count_I   = length(which(crossing(Heroes.infomap, Heroes)))
)
# Display in combined tibble:
tibble(Hero_in_Louvain = head(ends(Heroes, which(crossing(Heroes.louvain, Heroes))$label))[1:1],
Cross_Count_L   = length(which(crossing(Heroes.louvain, Heroes))),
Hero_in_Infomap = head(ends(Heroes, which(crossing(Heroes.infomap, Heroes))))[1:1],
Cross_Count_I   = length(which(crossing(Heroes.infomap, Heroes)))
)
# Display in combined tibble:
tibble(Hero_in_Louvain = head(ends(Heroes, which(crossing(Heroes.louvain, Heroes)))$label)[1:1],
Cross_Count_L   = length(which(crossing(Heroes.louvain, Heroes))),
Hero_in_Infomap = head(ends(Heroes, which(crossing(Heroes.infomap, Heroes))))[1:1],
Cross_Count_I   = length(which(crossing(Heroes.infomap, Heroes)))
)
# Display in combined tibble:
tibble(Hero_in_Louvain = head([ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label)[1:1],
# Display in combined tibble:
tibble(Hero_in_Louvain = V(Heroes)(ends(Heroes, which(crossing(Heroes.louvain, Heroes)))$label)[1:1],
Cross_Count_L   = length(which(crossing(Heroes.louvain, Heroes))),
Hero_in_Infomap = head(ends(Heroes, which(crossing(Heroes.infomap, Heroes))))[1:1],
Cross_Count_I   = length(which(crossing(Heroes.infomap, Heroes)))
)
# Display in combined tibble:
tibble(Hero_in_Louvain = V(Heroes)(ends(Heroes, which(crossing(Heroes.louvain, Heroes))))$label[1:1],
Cross_Count_L   = length(which(crossing(Heroes.louvain, Heroes))),
Hero_in_Infomap = head(ends(Heroes, which(crossing(Heroes.infomap, Heroes))))[1:1],
Cross_Count_I   = length(which(crossing(Heroes.infomap, Heroes)))
)
# Display in combined tibble:
tibble(Hero_in_Louvain = head(ends(Heroes, which(crossing(Heroes.louvain, Heroes))))$label[1:1],
Cross_Count_L   = length(which(crossing(Heroes.louvain, Heroes))),
Hero_in_Infomap = head(ends(Heroes, which(crossing(Heroes.infomap, Heroes))))[1:1],
Cross_Count_I   = length(which(crossing(Heroes.infomap, Heroes)))
)
# Display the top 20 crossing vertices and the number of edges via
# which they connect to others outside their partition, for both
# Louvain and Infomap. I suggest taking these steps
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:20]
# Compute crossings for Infomap, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.infomap, Heroes)))]$label), decreasing = TRUE)[1:20]
# Display in combined tibble:
tibble(Hero_in_Louvain = head(ends(Heroes, which(crossing(Heroes.louvain, Heroes))))[1:1],
Cross_Count_L   = length(which(crossing(Heroes.louvain, Heroes))),
Hero_in_Infomap = head(ends(Heroes, which(crossing(Heroes.infomap, Heroes))))[1:1],
Cross_Count_I   = length(which(crossing(Heroes.infomap, Heroes)))
)
# include_graphics("Images/heroes-louvain.png")
# include_graphics("Images/heroes-infomap.png")
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:20]
# Compute crossings for Infomap, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.infomap, Heroes)))]$label), decreasing = TRUE)[1:20]
# include_graphics("Images/heroes-pagerank.png")
include_graphics("Images/heroes-pagerank.png")
include_graphics("Images/Captain-America-infomap.png")
include_graphics("Images/Captain-America-infomap.png")
include_graphics("Images/heroes-infomap.png")
include_graphics("Images/Spiderman-louvain.png")
include_graphics("Images/heroes-louvain.png")
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# For including images of these types
library(jpeg)
library(png)
setwd("/Users/frederickstraub/Documents/College/UHM/ICS-422/Assignment/Analysis 7 Community Detection")
# Utilities may be added here.
include_graphics("Images/heroes-louvain.png")
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# For including images of these types
library(jpeg)
library(png)
setwd("/Users/frederickstraub/Documents/College/UHM/ICS-422/Assignment/Analysis 7 Community Detection")
# Utilities may be added here.
PS_v1 <- read_graph("Networks/sp_data_school_day_1_2_multigraph.graphml",
format="graphml")
summary(PS_v1)
print(paste("Before simplify: max count =", max(E(PS_v1)$count),
"max duration =", max(E(PS_v1)$duration)),
quote=FALSE)
PS_v2 <- simplify(PS_v1, edge.attr.comb = list(weight="sum", duration="sum", count="sum", "ignore"))
print(paste("After simplify: max count =", max(E(PS_v2)$count),
"max duration =", max(E(PS_v2)$duration)),
quote=FALSE)
summary(PS_v2)
table(E(PS_v2)$count, E(PS_v2)$duration)[1:12,1:12]
PSF <- delete_edges(PS_v2, E(PS_v2)[duration < (count*20) + 40])
PSF$name <- "Filtered Primary School Contacts"
# Expecting 242 vertices 2759 edges
summary(PSF)
table(count=E(PSF)$count, duration=E(PSF)$duration)[1:10,1:12]
V(PSF)$grade <- substr(V(PSF)$classname, 1, 1)
table(V(PSF)$grade)
V(PSF)$gender <- replace(V(PSF)$gender, V(PSF)$gender=="Unknown", "U")
sort(unique(V(PSF)$gender))
V(PSF)$classname <- replace(V(PSF)$classname,
V(PSF)$classname=="Teachers", "T")
sort(unique(V(PSF)$classname))
PSF.infomap <- cluster_infomap(PSF, e.weights = E(PSF)$duration)
sizes(PSF.infomap)
PSF.louvain <- cluster_louvain(PSF, weights = E(PSF)$duration)
sizes(PSF.louvain)
modularity(PSF.louvain)
modularity(PSF, membership(PSF.louvain))
# Reminder: unlike Analysis 6, grade now includes "T"
rbind(
tibble(metric = "Modularity",
Classname = modularity(PSF, as.numeric(as.factor(V(PSF)$classname))),
Grade     = modularity(PSF, as.factor(V(PSF)$grade)),
Louvain   = modularity(PSF.louvain),
InfoMap   = modularity(PSF.infomap),
),
tibble(metric = "Assortativity",
Classname = assortativity_nominal(PSF, as.numeric(as.factor(V(PSF)$classname))),
Grade     = assortativity_nominal(PSF, as.factor(V(PSF)$grade)),
Louvain   = assortativity_degree(PSF, membership(PSF.louvain)),
InfoMap   = assortativity_nominal(PSF, membership(PSF.infomap))
)
)
# Using any approach you prefer, make a correlation matrix of this form:
# partition  Classname  Grade      InfoMap    Louvain
# Classname  x.xxxxx    x.xxxxx    x.xxxxx    x.xxxxx
# Grade      x.xxxxx    x.xxxxx    x.xxxxx    x.xxxxx
# InfoMap    x.xxxxx    x.xxxxx    x.xxxxx    x.xxxxx
# Louvain    x.xxxxx    x.xxxxx    x.xxxxx    x.xxxxx
# I ended up using a conventional programming for-loop approach. There
# is probably an elegant R-style approach, but the tibble-based
# solution I constructed required repeating code that constructs
# membership lists, which did not seem any more elegant than a loop.
rbind(
tibble(partition = "Classname",
Classname = compare(as.numeric(as.factor(V(PSF)$classname)), as.numeric(as.factor(V(PSF)$classname)), method="nmi"),
Grade     = compare(as.numeric(as.factor(V(PSF)$classname)), as.factor(V(PSF)$grade), method="nmi"),
InfoMap   = compare(as.numeric(as.factor(V(PSF)$classname)), membership(PSF.infomap), method="nmi"),
Louvain   = compare(as.numeric(as.factor(V(PSF)$classname)), membership(PSF.louvain), method="nmi"),
),
tibble(partition = "Grade",
Classname = compare(as.factor(V(PSF)$grade), as.numeric(as.factor(V(PSF)$classname)), method="nmi"),
Grade     = compare(as.factor(V(PSF)$grade), as.factor(V(PSF)$grade), method="nmi"),
InfoMap   = compare(as.factor(V(PSF)$grade), membership(PSF.infomap), method="nmi"),
Louvain   = compare(as.factor(V(PSF)$grade), membership(PSF.louvain), method="nmi"),
),
tibble(partition = "InfoMap",
Classname = compare(membership(PSF.infomap), as.numeric(as.factor(V(PSF)$classname)), method="nmi"),
Grade     = compare(membership(PSF.infomap), as.factor(V(PSF)$grade), method="nmi"),
InfoMap   = compare(membership(PSF.infomap), membership(PSF.infomap), method="nmi"),
Louvain   = compare(membership(PSF.infomap), membership(PSF.louvain), method="nmi"),
),tibble(partition = "Louvain",
Classname = compare(membership(PSF.louvain), as.numeric(as.factor(V(PSF)$classname)), method="nmi"),
Grade     = compare(membership(PSF.louvain), as.factor(V(PSF)$grade), method="nmi"),
InfoMap   = compare(membership(PSF.louvain), membership(PSF.infomap), method="nmi"),
Louvain   = compare(membership(PSF.louvain), membership(PSF.louvain), method="nmi")
)
)
V(PSF)$louvain <- membership(PSF.louvain)
V(PSF)$infomap <- membership(PSF.infomap)
sort(unique(E(PSF)$weight))
E(PSF)$days <- E(PSF)$weight
E(PSF)$weight <- E(PSF)$duration
summary(PSF)
write_graph(PSF, "Filtered-Primary-School-Contacts.graphml", format="graphml")
include_graphics("Images/classname-partition.png", dpi=150)
# Please include a color key from Gephi here
include_graphics("Images/classname-palette.png")
include_graphics("Images/grade-partition.png", dpi=150)
# Please include a color key from Gephi here
include_graphics("Images/grade-palette.png")
include_graphics("Images/infomap-partition.png", dpi=150)
# Please include a color key from Gephi here
include_graphics("Images/infomap-palette.png")
include_graphics("Images/louvain-partition.png", dpi=150)
include_graphics("Images/louvain-palette.png")
include_graphics("Images/grade-gap.png")
include_graphics("Images/classname-gap.png")
# include_graphics("Images/cross-cluster.png")
Heroes <- read_graph("Networks/Hero-Coappearance-Network.graphml",
format="graphml")
summary(Heroes)
Heroes.louvain     <- cluster_louvain(Heroes)
Heroes.infomap     <- cluster_infomap(Heroes)
V(Heroes)$louvain  <- membership(Heroes.louvain)
V(Heroes)$infomap  <- membership(Heroes.infomap)
V(Heroes)$degree   <- degree(Heroes)
V(Heroes)$wdegree  <- strength(Heroes)
V(Heroes)$pagerank <- page_rank(Heroes)$vector
summary(Heroes)
write_graph(Heroes,"Hero-Communities.graphml", format="graphml")
# Display the top 20 crossing vertices and the number of edges via
# which they connect to others outside their partition, for both
# Louvain and Infomap. I suggest taking these steps
# Compute crossings for Louvain, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.louvain, Heroes)))]$label), decreasing = TRUE)[1:20]
# Compute crossings for Infomap, sorted decreasing by crossing:
sort(table(V(Heroes)[ends(Heroes, which(crossing(Heroes.infomap, Heroes)))]$label), decreasing = TRUE)[1:20]
# Display in combined tibble:
tibble(Hero_in_Louvain = head(ends(Heroes, which(crossing(Heroes.louvain, Heroes))))[1:1],
Cross_Count_L   = length(which(crossing(Heroes.louvain, Heroes))),
Hero_in_Infomap = head(ends(Heroes, which(crossing(Heroes.infomap, Heroes))))[1:1],
Cross_Count_I   = length(which(crossing(Heroes.infomap, Heroes)))
)
install.package('statnet')
install.packages("statnet")
install.packages(c("intergraph", "coda", "latticeExtra"))
install.packages(c("blob", "broom", "cli", "clipr", "cluster", "colorspace", "crayon", "DEoptimR", "desc", "dplyr", "evaluate", "fansi", "generics", "glue", "haven", "igraph", "jsonlite", "knitr", "magrittr", "MASS", "Matrix", "mgcv", "networkDynamic", "nlme", "openssl", "pillar", "pracma", "processx", "RColorBrewer", "Rcpp", "RCurl", "readr", "readxl", "rlang", "rmarkdown", "robustbase", "rprojroot", "scales", "survival", "testthat", "tidyr", "tidyselect", "tinytex", "tzdb", "uuid", "vctrs", "waldo", "withr", "xfun", "yaml"))
library(igraph)  # just using this to read in our familiar examples
library(tibble)  # for some output
library(network)    # the graph representation used in statnet
library(intergraph) # conversion utility between igraph and network
library(sna)        # analysis methods: notice masking of igraph
# Set the directory you are working in
setwd("/Users/frederickstraub/GitHub/ICS422/R-Files")
?rgraph
g <- rgraph(20)
class(g)
?as.network
gn <- as.network(g)
gn
plot(gn)
?rgnm
PS <- read_graph("Networks/Primary-School-5-Minute-Contacts.graphml",
format="graphml")
summary(PS)
PS_adj <- as_adjacency_matrix(PS)
PS_adj[1:20,1:20]
?as_data_frame # use the igraph version
PS_attrs <- igraph::as_data_frame(PS, what="vertices")
head(PS_attrs)
# Make a network object out of the adjacency matrix. Turns out PS_adj
# is a sparse matrix but as.network needs a plain matrix.
class(PS_adj)
class(as.matrix(PS_adj))
?as.network
PSN <- as.network(as.matrix(PS_adj), directed=FALSE)
PSN
?set.vertex.attribute # Ambiguous without the package name
?network::set.vertex.attribute # scroll way down
network::set.vertex.attribute(PSN, "classname", PS_attrs$classname)
network::set.vertex.attribute(PSN, "gender", PS_attrs$gender)
PSN
# install.packages('intergraph')
library(intergraph)
?asNetwork
?asIgraph
PS_network <- asNetwork(PS)
PS_network
PSN
PS_igraph <- asIgraph(PS_network)
summary(PS)
summary(PS_igraph)
all(V(PS)$label == V(PS_igraph)$label)
all(V(PS)$gender == V(PS_igraph)$gender)
all(V(PS)$classname == V(PS_igraph)$classname)
all(V(PS)$count == V(PS_igraph)$count)
all(V(PS)$duration == V(PS_igraph)$duration)
head(V(PS)$na)
head(V(PS)$vertex.names)
list.vertex.attributes(PS_network)
list.edge.attributes(PS_network)
save(PS_network, file="Primary-School-5M-Contacts-Network.rdata")
TI <- igraph::read_graph("Networks/TI-Chats-Week-of-060401.graphml",
format="graphml")
TI_network <- asNetwork(TI)
TI_network # correctly makes it directed
save(TI_network, file="TI-Chats-Week-of-06040.rdata")
TIC <- igraph::read_graph("Networks/TappedInChatSample.graphml",
format="graphml")
TIC_network <- asNetwork(TIC)
TIC_network
save(TIC_network, file="TappedInChatSample.rdata")
?sna
network.size(PS_network)
network.edgecount(PS_network)
list.vertex.attributes(PS_network)
list.edge.attributes(PS_network)
list.vertex.attributes(TIC_network)
list.edge.attributes(TI_network)
head(get.vertex.attribute(PS_network, "classname"), 10)
head(get.edge.attribute(PS_network, "duration"), 10)
?sna::degree # SNA verson: the igraph one is masked or not loaded
head(degree(TI_network), 20)
?sna::betweenness
head(betweenness(TI_network), 20)
head(betweenness(TI_network, rescale=TRUE), 20) # normalized
?prestige
head(prestige(TIC_network), 20)
head(prestige(TIC_network, cmode="indegree"), 20)
head(prestige(PS_network, gmode="graph", cmode="eigenvector"), 20)
l <- 20
tibble(
indegree = head(degree(TIC_network, cmode="indegree"), l),
indomain = head(prestige(TIC_network, cmode="domain"), l),
actor = head(get.vertex.attribute(TIC_network, "actor"), l),
contribution = head(get.vertex.attribute(TIC_network, "contribution"), l)
)
?connectedness
connectedness(PS_network)
connectedness(TI_network)
connectedness(TIC_network)
?sna::triad.census
triad.census(PS_network)
?brokerage # various kinds of mediating roles (bridges, etc)
PS_b <- brokerage(PS_network,
get.vertex.attribute(PS_network, "classname"))
names(PS_b)
head(PS_b$z.nli) # normalized z scores for each role
summary(PS_b$z.nli)
?sedist # distance metric based on structural equivalence
PS_sed <- sedist(PS_network)
plot(cmdscale(as.dist(PS_sed)))
plot(cmdscale(as.dist(PS_sed)))
?equiv.clust # note sedist is the default
PS_eq <- equiv.clust(PS_network)
plot(PS_eq) # groups nodes by their structural equivalence
?blockmodel # a way of summarizing cluster analysis
library(igraph) # in case we want to jump back to our familiar world
setwd("~/Desktop/Network-Science-Demos") # Or yours
library(network)
library(ergm)
library(sna)
# Optional: This makes pretty plots specialized for ERGMs
# install.packages('coda')
library('coda')
# install.packages('latticeExtra')
library('latticeExtra')
?ergm
data(package='ergm') # tells us the datasets in our packages
data(florentine)     # loads flomarriage and flobusiness data
flomarriage # note vertex attributes
plot.network(flomarriage, label = flomarriage %v% "vertex.names")
flomodel.e <- ergm(flomarriage ~ edges)
class(flomodel.e)
names(flomodel.e)
flomodel.e$formula # Formula we used
coef(flomodel.e)   # Coefficients (flomodel.e$coef depreciated)
summary(flomodel.e)
(edges.coef <- coef(flomodel.e)[1])
exp(edges.coef)/(1 + exp(edges.coef))
network.size(flomarriage)
network.edgecount(flomarriage)
20/((16*15)/2)
l_to_p <- function(l) {exp(l)/(1 + exp(l))}
l_to_p(edges.coef)
flomodel.et <- ergm(flomarriage ~ edges + triangle)
mcmc.diagnostics(flomodel.et)
summary(flomodel.et)
flomodel.et$formula
coef(flomodel.et)
(et.edges.coef = coef(flomodel.et)[1])
(et.triangle.coef = coef(flomodel.et)[2])
(et.logodds = et.edges.coef + c(0,1,2,3) * et.triangle.coef)
l_to_p(et.logodds)
(wealth <- flomarriage %v% 'wealth')
plot(flomarriage, vertex.cex=wealth/25,
label= flomarriage %v% "vertex.names")
?nodecov # and search within page
flomodel.ew <- ergm(flomarriage ~ edges + nodecov('wealth'))
summary(flomodel.ew)
data(samplk)
ls()          # There are different ones
samplk3       # We will use this one
plot(samplk3, label = samplk3 %v% "vertex.names")
summary(flomodel.ew)
data(samplk)
ls()          # There are different ones
samplk3       # We will use this one
plot(samplk3, label = samplk3 %v% "vertex.names")
?mutual
sampmodel.em <- ergm(samplk3 ~ edges + mutual)
mcmc.diagnostics(sampmodel.em)
summary(sampmodel.em)
samplk3 %v% 'group'
sampmodel.emgm <- ergm(samplk3 ~ edges + mutual + nodematch('group'))
mcmc.diagnostics(sampmodel.emgm)
summary(sampmodel.emgm)
sampmodel.emgf <- ergm(samplk3 ~ edges + mutual + nodefactor('group'))
mcmc.diagnostics(sampmodel.emgf)
summary(sampmodel.emgf)
sampmodel.emtg <- ergm(samplk3 ~ edges + mutual + triangle + nodematch('group'))
mcmc.diagnostics(sampmodel.emtg)
summary(sampmodel.emtg)
data(faux.mesa.high)
mesa <- faux.mesa.high           # just for shorthand
mesa                             # to see the attribute names to use
mcoord <- plot(mesa, vertex.col='Grade')
legend('bottomleft',fill=7:12,legend=paste('Grade',7:12),cex=0.75)
plot(mesa, vertex.col='Race', label = mesa %v% 'Sex', coord=mcoord)
legend('bottomleft',fill=7:12,legend=paste('Race',7:12),cex=0.75)
?nodematch
mesa.esgr <- ergm(mesa ~ edges +
nodematch('Sex') +
nodematch('Grade',diff=TRUE) +
nodematch('Race',diff=TRUE))
summary(mesa.esgr)
table(mesa %v% 'Race') # Frequencies of race
mixingmatrix(mesa, "Race")
# A network with missing edge data for two pairs.
missnet <- network.initialize(10,directed=FALSE)
missnet[1,2] <- missnet[2,7] <- missnet[3,6] <- 1
missnet[4,6] <- missnet[4,9] <- NA   # missing data
missnet    # Notice the "missing edges= 2"
miscoord <- plot(missnet, displaylabels=TRUE) # Save coordinates
ergm(missnet ~ edges + degree(2))
# Add the missing data
missnet[4,6] <- missnet[4,9] <- 0
plot(missnet, displaylabels=TRUE, coord=miscoord)  # looks the same but ...
missnet        # missing edges no longer recorded
ergm(missnet ~ edges + degree(2))
# In the above, one node has degree 2 and nine do not. So, the
#######################################################################
#######################################################################
# Insert Here: discussion of chapters 6 and 7, and model terms
#######################################################################
# Insert Here: discussion of chapters 6 and 7, and model terms
#######################################################################
