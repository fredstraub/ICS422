paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67)
plot_pl_distribution(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
# Add a legend with k-min and k-max
# Plot cumulative in-degree distribution
# Add a legend with fit_power_law parameters xmin, alpha, KS.p and KS.stat
?cex
??cex
# Plot in-degree distribution with linear binning
plot_pl_distribution <- function(g, title, mode="all",
geodesic=FALSE, cex=1.0) {
#
# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67)
plot(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67, aging.bin = 1000)
plot(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
plot(HEP.age.p10)
plot(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE)
# Plot in-degree distribution with linear binning
plot_pl_distribution <- function(g, title, mode="all",
geodesic=FALSE, cex=1.0) {
#
# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67, aging.bin = 1000)
plot(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
# Plot in-degree distribution with linear binning
plot_pl_distribution <- function(g, title, mode="all",
geodesic=FALSE, cex=1.0) {
#
# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67)
plot(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
# Plot in-degree distribution with linear binning
plot_pl_distribution <- function(g, title, mode="all",
geodesic=FALSE, cex=1.0) {
#
# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67)
plot_pl_distribution(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
# Add a legend with k-min and k-max
# Plot cumulative in-degree distribution
# Add a legend with fit_power_law parameters xmin, alpha, KS.p and KS.stat
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# For including images of these types
library(jpeg)
library(png)
# Utility for plotting degree distributions
source("Utility/degree_domain.R")
par(mfrow=c(1,1))
PG <- read_graph("Networks/power_grid.gml", format="gml")
summary(PG)
include_graphics("power-grid-degree.png")
include_graphics("power-grid-closeup.png")
PG.config <- sample_degseq(degree(PG), method = "vl")
?mean(degree)
# Mean Degree and log(|V|) is the same for both networks, so we
# only need one table. I recommend using tibble.
models <- list(PG, PG.config)
mnames <- c("Power-Grid", "Config")
PG.metrics <- tibble(
Model   = mnames,
V       = sapply(models, vcount),
E       = sapply(models, ecount),
)
PG.metrics
# Display global transitivity, degree correlation, and mean distance
# in a table with each row labeled. You can make a tibble for each row,
# and then combine them with add_row for display.
PG.metrics2 <- tibble(
Model        = mnames,
transitivity = sapply(models, transitivity, type="global")
)
PG.metrics3 <- tibble(
Model        = mnames,
degreeassort = sapply(models, assortativity_degree)
)
PG.metrics4 <- tibble(
Model    = mnames,
meandist = sapply(models, mean_distance)
)
PG.metrics2 <- PG.metrics %>% add_column(transitivity = sapply(models, transitivity, type="global")) %>% add_column(degreeassort = sapply(models, assortativity_degree)) %>% add_column(meandist = sapply(models, mean_distance))
PG.metrics2
# Frequency table of component sizes (no tibble needed, just use table)
count_components(PG)
# Plot degree distribution with linear binning
# Include legend with k-min and k-max
plot(degree_domain(PG), degree_distribution(PG), main="Power-Grid Degree Distribution Log Log", xlab="k", ylab="p(k)", log ="xy")
# Plot cumulative degree distribution
plot(degree_domain(PG), degree_distribution(PG, cumulative = TRUE), main = "Power-Grid Cumulative Degree Distribution Log Log", xlab = "k", ylab = "CDF p(k)", log = "xy")
# Display table (tibble) with fit_power_law results from the plfit method.
as_tibble(PG.plfit <- fit_power_law(degree(PG), implementation = "plfit"))
# try to cover more of the data.
as_tibble(PG.plfit <- fit_power_law(degree(PG), implementation = "plfit", xmin = 1))
PG_gnm <- sample_gnm(vcount(PG), ecount(PG))
round(mean(degree(PG)), 1)
round(mean(degree(PG.config)), 1)
HEP <- read_graph("Networks/cit-HepTh.gml", format="gml")
summary(HEP)
# Plot in-degree distribution with linear binning
plot(degree_domain(HEP, mode="in"), degree_distribution(HEP, mode="in"), log="xy", xlab = "k", ylab = "p(k)", main = "In-Degree Distribution HEP")
# Add a legend with k-min and k-max
plfit_legend <- function(g) {
g.plfit <- fit_power_law(degree(g), implementation="plfit")
legend("bottomleft", bty="n", cex=1.2,
c(paste("kmin =", min(degree(g))),
paste("kmax =", max(degree(g)))))}
plfit_legend(HEP)
# Plot cumulative in-degree distribution
plot(degree_domain(HEP, mode="in"), degree_distribution(HEP, mode="in", cumulative = TRUE), log="xy", xlab = "k", ylab = "p(k)", main = "In-Degree Cumulative Distribution HEP")
# Add a legend with fit_power_law parameters xmin, alpha, KS.p and KS.stat
plfit_legend <- function(g) {
g.plfit <- fit_power_law(degree(g), implementation="plfit")
legend("bottomleft", bty="n", cex=1.2,
c(paste("xmin =", g.plfit$xmin),
paste("alpha = ", round(g.plfit$alpha, digits=2)),
paste("KS p = ", round(g.plfit$KS.p, digits=3)),
paste("KS.stat = ", round(g.plfit$KS.stat, digits=3))))}
plfit_legend(HEP)
# Plot out-degree distribution with linear binning
plot(degree_domain(HEP, mode="out"), degree_distribution(HEP, mode="out"), log="xy", xlab = "k", ylab = "p(k)", main = "Out-Degree Distribution HEP")
# Add a legend with k-min and k-max
plfit_legend <- function(g) {
g.plfit <- fit_power_law(degree(g), implementation="plfit")
legend("bottomleft", bty="n", cex=1.2,
c(paste("kmin =", min(degree(g))),
paste("kmax =", max(degree(g)))))}
plfit_legend(HEP)
# Plot cumulative out-degree distribution
plot(degree_domain(HEP, mode="out"), degree_distribution(HEP, mode="out", cumulative = TRUE), log="xy", xlab = "k", ylab = "p(k)", main = "Out-Degree Cumulative Distribution HEP")
# Add a legend with fit_power_law parameters xmin, alpha, KS.p and KS.stat
plfit_legend <- function(g) {
g.plfit <- fit_power_law(degree(g), implementation="plfit")
legend("bottomleft", bty="n", cex=1.2,
c(paste("xmin =", g.plfit$xmin),
paste("alpha = ", round(g.plfit$alpha, digits=2)),
paste("KS p = ", round(g.plfit$KS.p, digits=3)),
paste("KS.stat = ", round(g.plfit$KS.stat, digits=3))))}
plfit_legend(HEP)
# Provide the sample_pa_age code that generates your best model.
# Print a table of parameters m, attachment preference, initial
# attractiveness, and aging. Again, tibbles make nice output.
# Plot in-degree distribution with linear binning
plot_pl_distribution <- function(g, title, mode="all",
geodesic=FALSE, cex=1.0) {
#
# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67)
plot_pl_distribution(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=cex)
# Plot in-degree distribution with linear binning
plot_pl_distribution <- function(g, title, mode="all",
geodesic=FALSE, cex=1.0) {
#
# Distributions and metrics we'll need
g.deg   <- degree(g, mode=mode)
g.dom   <- degree_domain(g, mode=mode)
g.dis   <- degree_distribution(g, mode=mode)
g.cum   <- degree_distribution(g, mode=mode, cumulative=TRUE)
g.plfit <- fit_power_law(g.deg, implementation = "plfit")
g.trans <- transitivity(g, type="global")
g.wcc   <- components(g, mode="weak")$no
g.scc   <- components(g, mode="strong")$no
g.dass  <- assortativity_degree(g)
# The slow one. Expect delay before plot starts.
if (geodesic) {g.dist <- mean_distance(g)}
#
# Regular distribution with metrics
plot(g.dom, g.dis, main=paste(title, "Log"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("topright", bty="n", cex=cex,
c(paste("|V|=", vcount(g), " |E|=", ecount(g), sep=""),
paste("Transitivity:", round(g.trans, digits=4)),
if (geodesic) {
paste("Mean Geodesic: ", round(g.dist, digits=2))},
paste("Assortativity:", round(g.dass, digits=4)),
paste("WCC:", g.wcc, "SCC:", g.scc)
))
#
# CDF with power law fit.
plot(g.dom, g.cum, main=paste(title, "CDF"),
log="xy", xlab="k", ylab="p(k)",
cex.axis=cex, cex.lab=cex)
legend("bottomleft", bty="n", cex=cex,
c(paste("plfit gamma =", round(g.plfit$alpha, 2)),
paste("plfit xmin =", g.plfit$xmin),
paste("plfit KS.stat =", round(g.plfit$KS.stat, 2)),
paste("plfit KS.p", round(g.plfit$KS.p, 2))))
legend("topright", bty="n", cex=cex,
c(paste("k min: ", min(g.deg)),
paste("k max: ", max(g.deg))))
}
# False for slow computer or in class demo; True to see geodesics.
geo=TRUE
# aging.exp = 10
HEP.age.p10 <- sample_pa_age(vcount(HEP), pa.exp=1.05, m=6,
aging.exp=-1.67)
plot_pl_distribution(HEP.age.p10, "HEP - sample_pa_age",
geodesic=FALSE, cex=1.0)
# Add a legend with k-min and k-max
# Plot cumulative in-degree distribution
# Add a legend with fit_power_law parameters xmin, alpha, KS.p and KS.stat
library(igraph)
library(tibble)
setwd("~/Desktop/Network-Science-Demos") # Set to yours
source("Utility/degree_domain.R")
setwd("/Users/frederickstraub/GitHub/ICS422/R-Files") # Set to yours
source("Utility/degree_domain.R")
WA <- read_graph("Networks/EuroSiS-WebAtlas-Multigraph.graphml",
format="graphml")
summary(WA)
ivity # all are documented together
?assortativity # all are documented together
head(V(WA)$country)              # not numeric
head(V(WA)$country)              # not numeric
head(as.integer(V(WA)$country))  # Can't convert character vector
WA_country_nums <- as.integer(as.factor(V(WA)$country))
head(WA_country_nums) # numeric
head(as.factor(V(WA)$country))
WA_country_nums <- as.integer(as.factor(V(WA)$country))
head(V(WA)$country)              # not numeric
head(as.integer(V(WA)$country))  # Can't convert character vector
head(as.factor(V(WA)$country))
WA_country_nums <- as.integer(as.factor(V(WA)$country))
head(WA_country_nums) # numeric
WA_actor_nums <- as.numeric(as.factor(V(WA)$actor_type))
assortativity_nominal(WA, WA_country_nums)
assortativity_nominal(WA, WA_actor_nums)
?modularity
tibble(Attribute     = c("country", "actor-type"),
Assortativity = c(assortativity_nominal(WA, WA_country_nums),
assortativity_nominal(WA, WA_actor_nums)),
Modularity    = c(modularity(WA, WA_country_nums),
modularity(WA, WA_actor_nums)))
modularity(WA, WA_country_nums)  # Default
modularity(WA, WA_country_nums, weights=rep.int(1, ecount(WA)))
modularity(WA, WA_country_nums, weights=E(WA)$weight)
assortativity_nominal(WA, (as.integer(V(WA)$tag_research) + 1))
assortativity_nominal(WA, (as.integer(V(WA)$tag_space) + 1))
assortativity_nominal(WA, (as.integer(V(WA)$tag_gender) + 1))
?rewire   # just as a reminder
f <- 1000 # Change f to 100 on a slow computer.
WA.rewired <- rewire(WA, with = keeping_degseq(niter = ecount(WA)*f))
assortativity_nominal(WA, WA_country_nums)
assortativity_nominal(WA.rewired, WA_country_nums)
assortativity_nominal(WA, WA_actor_nums)
assortativity_nominal(WA.rewired, WA_actor_nums)
g.mult <- sample_fitness_pl(10000, 100000, 2.1,
loops=TRUE, multiple=TRUE,
finite.size.correction = FALSE)
g.simp <- sample_fitness_pl(10000, 100000, 2.1,
loops=FALSE, multiple=FALSE,
finite.size.correction = FALSE)
plot(degree_domain(g.mult),
degree_distribution(g.mult, cumulative=TRUE), log="xy",
main="Simple and Multi Degree Dist", xlab="k", ylab="p(k)",
pch=18, col="blue")
points(degree_domain(g.simp),
degree_distribution(g.simp, cumulative = TRUE),
pch=20, col="red")
legend("bottomleft", bty="n",
c("simple", "multi"),
col   =c("red", "blue"),
lty=1, lwd=5)
assortativity_degree(g.mult)
assortativity_degree(g.simp)
PB <- read_graph("Networks/political-blogs.graphml", format="graphml")
summary(PB)
unique(V(PB)$value)
PB_side <- as.integer(as.factor(V(PB)$label))
assortativity_nominal(PB, PB_side)
PB_side <- as.integer(as.factor(V(PB)$value))
assortativity_nominal(PB, PB_side)
YP <- read_graph("Networks/Yeast-Proteins.graphml", format="graphml")
summary(YP)
unique(V(YP)$Class)
YP_class <- as.integer(as.factor(V(YP)$class))
assortativity_nominal(YP, Class)
assortativity_nominal(YP, $Class)
assortativity_nominal(YP, YP_class)
YP_class <- as.integer(as.factor(V(YP)$Class))
assortativity_nominal(YP, YP_class)
YP_class <- as.integer(as.factor(V(YP)$Class))
assortativity_nominal(YP, YP_class)
