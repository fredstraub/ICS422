install.packages('swirl')
install.packages('igraph')
install.packages('tidyverse')
install.packages('poweRlaw')
install.packages('linkcomm')
install.packages('statnet')
library('igraph')
update.packages()
library(igraph)
g = Graph()
g = Graph()
g
? graph
?make_directed_graph
g <= make_directed_graph([1,2], [2,1], [1,3],[3,1],[1,4],[2,4],[4,3])
g = make_directed_graph([1,2], [2,1], [1,3],[3,1],[1,4],[2,4],[4,3])
make_directed_graph(g([1,2], [2,1], [1,3],[3,1],[1,4],[2,4],[4,3]))
g <- make_directed_graph((1,2))
make_directed_graph(g(1,2))
make_directed_graph((1,2))
directed_graph(1,2)
g <= directed_graph(1,2)
plot(dg)
dg<-graph.formula(Tom-+Mary, Tom-+Bill, Tom-+Sam, Sue+-Mary, Bill-+Sue)
dg<-graph.formula(Tom-+Mary, Tom-+Bill, Tom-+Sam, Sue+-Mary, Bill-+Sue)
plot(dg)
g<-graph.formula(v1++v2, v1++v3, v1-+v4, v2-+v4, v3-+v4)
plot(g)
g5<-graph.formula(v1++v2, v1++v3, v1-+v4, v2-+v4, v4-+v3)
plot(g5)
?page.rank
page_rank(g5, damping = 1)
page_rank(g5, damping = 1)$vector
page_rank(g5)$vector
page_rank(g5, damping = 1)$vector
page_rank(g5, damping = 0)$vector
page_rank(g5, damping = 0)$vector
page_rank(g5, damping = 0.85)$vector
page_rank(g5, damping = 0.85)$vector
page_rank(g5, damping = 0)$vector
page_rank(g5, damping = 1)$vector
page_rank(g5, damping = 0.85)$vector
page_rank(g5, damping = 0)$vector
eigen_centrality(g5)
eigen_centrality(g5)$vector
plot(g5)
g5<-graph.formula(v1++v2, v1++v3, v1-+v4, v2-+v4, v4-+v3)
page_rank(g5, damping = 1)$vector
page_rank(g5, damping = 0.85)$vector
page_rank(g5, damping = 0)$vector
eigen_centrality(g5)$vector
?eigen_centrality
eigen_centrality(g5, scale = 1)$vector
eigen_centrality(g5, scale = TRUE)$vector
eigen_centrality(g5, scale = FALSE)$vector
page_rank(g5, damping = 0)$vector
eigen_centrality(g5, scale = FALSE)$vector
eigen_centrality(g5, weights = 1)$vector
eigen_centrality(g5, scale = TRUE)$vector
eigen_centrality(g5, scale = FALSE)$vector
eigen_centrality(g5, scale = SUM TO 1)$vector
eigen_centrality(g5, scale = 1)$vector
eigen_centrality(g5, scale = 0.25)$vector
eigen_centrality(g5, scale = FALSE)$vector
g5<-graph.formula(v1++v2, v1++v3, v1-+v4, v2-+v4, v4-+v3)
page_rank(g5, damping = 1)$vector
page_rank(g5, damping = 0.85)$vector
page_rank(g5, damping = 0)$vector
eigen_centrality(g5, scale = FALSE)$vector
eigen_centrality(g5, directed = TRUE, scale = FALSE)$vector
eigen_centrality(g5, directed = TRUE, scale = TRUE)$vector
eigen_centrality(g5, directed = TRUE, scale = FALSE)$vector
page_rank(g5, directed = TRUE, damping = 1)$vector
page_rank(g5, damping = 1)$vector
page_rank(g5, damping = 0.85)$vector
page_rank(g5, damping = 0)$vector
eigen_centrality(g5, directed = TRUE, scale = FALSE)$vector
page_rank(g5, damping = 0.85)$vector
g5<-graph.formula(v1++v2, v1++v3, v1-+v4, v2-+v4, v4-+v3)
page_rank(g5, damping = 1)$vector
page_rank(g5, damping = 0.85)$vector
page_rank(g5, damping = 0)$vector
eigen_centrality(g5, directed = TRUE, scale = FALSE)$vector
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# Optional, for including images of these types
library(jpeg)
library(png)
# Utilities may be added here.
source("Utility/degree_domain.R")
source("Utility/nonzero_degree_distribution.R")
PS_v1 <- read_graph(PS_v1.graphml)
PS_v1 <- read_graph(PS_v1.graphml)
PS_v1 <- read_graph(networks/PS_v1.graphml)
PS_v1 <- read_graph(Networks/PS_v1.graphml)
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
?cluster_infomap
?cluster_infomap
?cluster_infomap
library(igraph)
setwd("~/Desktop/Network-Science-Demos") # Set to yours
NS <- read_graph("Networks/netscience.graphml", format="graphml")
summary(NS)
TI <- read_graph("Networks/TI-Chats-Week-of-060401.graphml", format="graphml")
summary(TI)
?communities
K <- make_graph("Zachary")
summary(K)
?cluster_optimal
K.opt <- cluster_optimal(K)
names(K.opt) # to see what information it returns
membership(K.opt)
modularity(K.opt)
modularity(K, membership(K.opt)) # same result
K.layout <- layout_with_fr(K)
plot_karate <- function(comm, title){
plot(comm, K, layout=K.layout,
main=paste0(title,
": M = ", round(modularity(comm), 4),
", # = ", length(comm)))
}
plot_karate(K.opt, "Optimal")
vcount(NS)
2^vcount(NS)
2^vcount(TI)
?cluster_edge_betweenness
K.eb <- cluster_edge_betweenness(K)
is_hierarchical(K.eb)
names(K.eb)
plot_karate(K.eb, "Edge Betweenness")
?cluster_fast_greedy
K.fg <- cluster_fast_greedy(K)
names(K.fg)
plot_karate(K.fg, "Fast Greedy")
?cluster_louvain
K.louvain <- cluster_louvain(K)
names(K.louvain)
modularity(K.louvain)
K.louvain$modularity
K.louvain$membership
K.louvain$memberships
plot_karate(K.louvain, "Louvain")
plot_karate(K.opt, "Optimal") # To compare
?cluster_infomap
?cluster_louvain
?communities
documented together
?assortativity # all are documented together
?crossing
library(igraph)
library(tibble)
setwd("~/Desktop/Network-Science-Demos") # Set to yours
source("Utility/new_window.R")
NS <- read_graph("Networks/netscience.graphml", format="graphml")
TI <- read.graph("Networks/TI-Chats-Week-of-060401.graphml", format="graphml")
?cluster_louvain
?cluster_infomap # has v.weights too, but we don't use it
summary(E(NS)$weight)
hist(E(NS)$weight, breaks=50)
NS_louvain_w <- cluster_louvain(NS)
V(NS)$comm_louvain_w <- membership(NS_louvain_w)
NS_infomap_w <- cluster_infomap(NS)
V(NS)$comm_infomap_w <- membership(NS_infomap_w)
NS_louvain_u <- cluster_louvain(NS, weights=NA)
V(NS)$comm_louvain_u <- membership(NS_louvain_u)
library(igraph)
library(tibble)
setwd("~/Desktop/Network-Science-Demos") # Set to yours
setwd("/Users/fred/Github/ICS422/R-Files") # Set to yours
source("Utility/new_window.R")
NS <- read_graph("Networks/netscience.graphml", format="graphml")
TI <- read.graph("Networks/TI-Chats-Week-of-060401.graphml", format="graphml")
?cluster_louvain
?cluster_infomap # has v.weights too, but we don't use it
summary(E(NS)$weight)
hist(E(NS)$weight, breaks=50)
NS_louvain_w <- cluster_louvain(NS)
V(NS)$comm_louvain_w <- membership(NS_louvain_w)
NS_infomap_w <- cluster_infomap(NS)
V(NS)$comm_infomap_w <- membership(NS_infomap_w)
NS_louvain_u <- cluster_louvain(NS, weights=NA)
V(NS)$comm_louvain_u <- membership(NS_louvain_u)
NS_infomap_u <- cluster_infomap(NS, e.weights=NA)
V(NS)$comm_infomap_u <- membership(NS_infomap_u)
clist <- list(NS_louvain_w, NS_louvain_u, NS_infomap_w, NS_infomap_u)
tibble(
method = c("Louvain W", "Louvain U", "InfoMap W", "InfoMap U"),
modularity = sapply(clist, modularity),
commcount  = sapply(clist, length)
)
table(sizes(NS_louvain_u))
table(sizes(NS_louvain_w))
NS_gnm <- sample_gnm(vcount(NS), ecount(NS))
NS_gnm_louvain <- cluster_louvain(NS_gnm)
NS_config         <- sample_degseq(degree(NS))
NS_config_louvain <- cluster_louvain(NS_config)
tibble(
graph = c("NS Original", "NS Config", "NS G(n,m)"),
modularity = c(modularity(NS_louvain_u),
modularity(NS_config_louvain),
modularity(NS_gnm_louvain)),
commcount  = c(length(NS_louvain_u),
length(NS_config_louvain),
length(NS_gnm_louvain))
)
table(sizes(NS_louvain_u))
table(sizes(NS_config_louvain))
table(sizes(NS_gnm_louvain))
TI_undirected <- as.undirected(TI, mode="collapse")
TI_gnm <- sample_gnm(vcount(TI_undirected), ecount(TI_undirected))
TI_gnm_louvain <- cluster_louvain(TI_gnm)
TI_rewired <- rewire(TI_undirected,
with = keeping_degseq(niter = ecount(TI) * 1000))
head(E(TI_undirected)$weight, 15)
head(E(TI_rewired)$weight, 15) # why does this make sense?
TI_cl <- cluster_louvain(TI_undirected, weights=NA)
TI_rewired_cl <- cluster_louvain(TI_rewired)
V(TI_undirected)$comm_louvain <- membership(TI_cl)
V(TI_rewired)$comm_louvain <- membership(TI_rewired_cl)
tibble(
graph = c("TI Original", "TI Rewire", "TI G(n,m)"),
modularity = c(modularity(TI_cl),
modularity(TI_rewired_cl),
modularity(TI_gnm_louvain)),
commcount  = c(length(TI_cl),
length(TI_rewired_cl),
length(TI_gnm_louvain))
)
?compare # Yes. We will study the three methods below.
# A small example first:
K <- make_graph("Zachary")
K_louvain <- cluster_louvain(K)
K_infomap <- cluster_infomap(K)
# Repeating our plotting from last class
K.layout <- layout_with_fr(K)
plot_karate <- function(comm, title){
plot(comm, K, layout=K.layout,
main=paste0(title,
": M = ", round(modularity(comm), 4),
", # = ", length(comm)))
}
plot_karate(K_louvain, "Louvain")
plot_karate(K_infomap, "InfoMap")
compare(K_louvain, K_infomap, method="split.join") # Find 6 nodes in plots
compare(K_louvain, K_louvain, method="split.join") # Perfect agreement
compare(K_louvain, K_infomap, method="rand")
compare(K_louvain, K_infomap, method="adjusted.rand")
compare(K_louvain, K_louvain, method="rand")
compare(K_louvain, K_louvain, method="adjusted.rand")
compare(K_louvain, K_infomap, method="vi")
compare(K_louvain, K_louvain, method="vi") # Perfect agreement
compare(K_louvain, K_infomap, method="nmi")
compare(K_louvain, K_louvain, method="nmi") # Perfect agreement
compare(NS_louvain_u, NS_infomap_u, method="split.join")    # swaps
compare(NS_louvain_u, NS_infomap_u, method="rand")          # % pairs agreeing
compare(NS_louvain_u, NS_infomap_u, method="adjusted.rand") # adjusted random
compare(NS_louvain_u, NS_infomap_u, method="vi")            # info distance
compare(NS_louvain_u, NS_infomap_u, method="nmi")           # info similarity
compare(NS_louvain_u, NS_config_louvain, method="split.join")
compare(NS_louvain_u, NS_config_louvain, method="rand")
compare(NS_louvain_u, NS_config_louvain, method="adjusted.rand") # wow!
compare(NS_louvain_u, NS_config_louvain, method="vi")
compare(NS_louvain_u, NS_config_louvain, method="nmi")
summary(NS) # has our igraph memberships
write_graph(NS, "Network-Science-Communities.graphml", format="graphml")
NS2 <- read_graph("Network-Science-Communities2.graphml", format="graphml")
summary(NS2)
?compare
head(sort(unique(V(NS2)$gephi_louvain))) # starts with 0
V(NS2)$gephi_louvain <- V(NS2)$gephi_louvain + 1
head(sort(unique(V(NS2)$gephi_louvain))) # now starts with 1
compare(membership(NS_louvain_w), V(NS2)$gephi_louvain, method="nmi")
compare(membership(NS_louvain_w), V(NS2)$gephi_louvain, method="vi")
compare(membership(NS_louvain_w), V(NS2)$gephi_louvain, method="adjusted.rand")
?crossing
crossing(NS_louvain_w, NS)[1:100]
length(which(crossing(NS_louvain_w, NS)))
crossing(NS_louvain_w, NS)[1:100]
length(which(crossing(NS_louvain_w, NS)))
length(which(crossing(NS_infomap_w, NS)))
head(E(NS)[which(crossing(NS_louvain_w, NS))])
?ends
head(ends(NS, which(crossing(NS_louvain_w, NS))))
tail(ends(NS, which(crossing(NS_louvain_w, NS))))
length(ends(NS, which(crossing(NS_louvain_w, NS))))
length(ends(NS, which(crossing(NS_louvain_w, NS)))[,1])
crossing(NS_louvain_w, NS)[1:100]
length(which(crossing(NS_louvain_w, NS)))
length(which(crossing(NS_infomap_w, NS)))
head(E(NS)[which(crossing(NS_louvain_w, NS))])
?ends
head(ends(NS, which(crossing(NS_louvain_w, NS))))
head(E(NS)[which(crossing(NS_louvain_w, NS))])
?ends
head(ends(NS, which(crossing(NS_louvain_w, NS))))
tail(ends(NS, which(crossing(NS_louvain_w, NS))))
length(ends(NS, which(crossing(NS_louvain_w, NS))))
crossing(NS_louvain_w, NS)[1:100]
length(which(crossing(NS_louvain_w, NS)))
length(which(crossing(NS_infomap_w, NS)))
head(V(NS)[ends(NS, which(crossing(NS_louvain_w, NS)))]$label)
head(E(NS)[which(crossing(NS_louvain_w, NS))])
head(ends(NS, which(crossing(NS_louvain_w, NS))))
tail(ends(NS, which(crossing(NS_louvain_w, NS))))
length(ends(NS, which(crossing(NS_louvain_w, NS))))
head(ends(NS, which(1, crossing(NS_louvain_w, NS))))
head(ends(NS, which(crossing(NS_louvain_w, NS))))
head(1, ends(NS, which(crossing(NS_louvain_w, NS))))
head(2, ends(NS, which(crossing(NS_louvain_w, NS))))
head(104, ends(NS, which(crossing(NS_louvain_w, NS))))
top(ends(NS, which(crossing(NS_louvain_w, NS))))
head(ends(NS, which(crossing(NS_louvain_w, NS))))
head(ends(NS, which(crossing(NS_louvain_w, NS))))[1:1]
