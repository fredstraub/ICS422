# Weighted Eigenvector Centrality
V(NS)$i_eigen_cent_w <- eigen_centrality(NS)$vector
# Unweighted Page Rank
V(NS)$i_page_rank_u  <- page_rank(NS, weights = NA)$vector
# Weighted Page Rank
V(NS)$i_page_rank_w  <- page_rank(NS)$vector
# Check that they are all there and none came out v/x
summary(NS)
icu <- (V(NS)$i_eigen_cent_u)
names(icu)
icu$value
head(icu$vector, 20)
summary(NS)
# Unweighted Degree
V(NS)$i_degree       <- degree(NS)
# Weighted Degree
V(NS)$i_strength     <- strength(NS)
# Unweighted Eigenvector Centrality
V(NS)$i_eigen_cent_u <- eigen_centrality(NS, weights = NA)$vector
# Weighted Eigenvector Centrality
V(NS)$i_eigen_cent_w <- eigen_centrality(NS)$vector
# Unweighted Page Rank
V(NS)$i_page_rank_u  <- page_rank(NS, weights = NA)$vector
# Weighted Page Rank
V(NS)$i_page_rank_w  <- page_rank(NS)$vector
# Check that they are all there and none came out v/x
summary(NS)
icu <- (V(NS)$i_eigen_cent_u)
names(icu)
icu$value
head(icu$vector, 20)
summary(NS)
clear
exit
clean_cache()
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# Optional, for including images of these types
library(jpeg)
library(png)
# Utilities
source("Utility/topnv.R")
NS <- read.graph("Networks/netscience.graphml", format="graphml")
summary(NS)
# Unweighted Degree
V(NS)$i_degree       <- degree(NS)
# Weighted Degree
V(NS)$i_strength     <- strength(NS)
# Unweighted Eigenvector Centrality
V(NS)$i_eigen_cent_u <- eigen_centrality(NS, directed = FALSE)$vector
# Weighted Eigenvector Centrality
V(NS)$i_eigen_cent_w <- eigen_centrality(NS)$vector
# Unweighted Page Rank
V(NS)$i_page_rank_u  <- page_rank(NS, weights = NA)$vector
# Weighted Page Rank
V(NS)$i_page_rank_w  <- page_rank(NS)$vector
# Check that they are all there and none came out v/x
summary(NS)
# Check that they are all there and none came out v/x
head(V(NS)$i_eigen_cent_u)
head(V(NS)$i_eigen_cent_w)
max(V(NS)$i_eigen_cent_u)
max(V(NS)$i_eigen_cent_w)
tibble(topnv(NS, V(NS)$i_eigen_cent_u))$label
tibble(topnv(NS, V(NS)$i_eigen_cent_u))$id
tibble(topnv(NS, V(NS)$i_eigen_cent_u))
summary(NS)
tibble(topnv(NS, V(NS)$i_eigen_cent_u))$degree
tibble(i_eigen_cent_u = topnv(NS, V(NS)$i_eigen_cent_u))$degree
tibble(i_eigen_cent_u = topnv(NS, V(NS)$i_eigen_cent_u))$label
tibble(i_eigen_cent_u = topnv(NS, V(NS)$i_eigen_cent_u))
# Unweighted Degree
V(NS)$i_degree       <- degree(NS)
# Weighted Degree
V(NS)$i_strength     <- strength(NS)
# Unweighted Eigenvector Centrality
V(NS)$i_eigen_cent_u <- eigen_centrality(NS, directed = FALSE)$vector
# Weighted Eigenvector Centrality
V(NS)$i_eigen_cent_w <- eigen_centrality(NS)$vector
# Unweighted Page Rank
V(NS)$i_page_rank_u  <- page_rank(NS, weights = NA)$vector
# Weighted Page Rank
V(NS)$i_page_rank_w  <- page_rank(NS)$vector
# Check that they are all there and none came out v/x
head(V(NS)$i_eigen_cent_u)
head(V(NS)$i_eigen_cent_w)
max(V(NS)$i_eigen_cent_u)
max(V(NS)$i_eigen_cent_w)
summary(NS)
# Check that they are all there and none came out v/x
head(V(NS)$i_eigen_cent_u, 10)
# Check that they are all there and none came out v/x
head(V(NS)$i_eigen_cent_u)
head(V(NS)$i_eigen_cent_w)
max(V(NS)$i_eigen_cent_u)
max(V(NS)$i_eigen_cent_w)
tail(V(NS)$i_eigen_cent_u)
tail(V(NS)$i_eigen_cent_w)
# Check that they are all there and none came out v/x
head(V(NS)$i_eigen_cent_u)
tail(V(NS)$i_eigen_cent_u)
max(V(NS)$i_eigen_cent_u)
head(V(NS)$i_eigen_cent_w)
tail(V(NS)$i_eigen_cent_w)
max(V(NS)$i_eigen_cent_w)
# Make a table showing topnv names and values for both metrics.
tibble(
degree = topnv(NS, V(NS)$degree)$label,
w_degree = topenv(NS, V(NS)$nw)$label
)
# Make a table showing topnv names and values for both metrics.
tibble(
w_degree = topenv(NS, V(NS)$nw)$label
)
# Make a table showing topnv names and values for both metrics.
max(NS)$indegree))
# Make a table showing topnv names and values for both metrics.
max(NS)$indegree)
# Make a table showing topnv names and values for both metrics.
max(NS)$indegree)
# Make a table showing topnv names and values for both metrics.
max(NS)$indegree)
# Make a table showing topnv names and values for both metrics.
max(NS)$indegree))
# Make a table showing topnv names and values for both metrics.
max(V(NS)$indegree)
# Make a table showing topnv names and values for both metrics.
max(V(NS)$degree)
# Make a table showing topnv names and values for both metrics.
max(V(NS)degree)
# Make a table showing topnv names and values for both metrics.
head(degree(NS))
# Make a table showing topnv names and values for both metrics.
head(degree(NS, 20))
# Make a table showing topnv names and values for both metrics.
head(degree(NS, 30))
# Make a table showing topnv names and values for both metrics.
head(degree(NS))
# Make a table showing topnv names and values for both metrics.
max(degree(NS))
# Make a table showing topnv names and values for both metrics.
V(NS)$label[V(degree(NS))]
# Make a table showing topnv names and values for both metrics.
V(NS)$label[(degree(NS))]
# Make a table showing topnv names and values for both metrics.
V(NS)$label[max(degree(NS))]
# Make a table showing topnv names and values for both metrics.
topnv <- function(graph, values, n=10) {
return(v(graph[order(values, decreasing = TRUE)[1:n]]))
}
tibble(
degree = topnv(NS, V(NS)$degree)$label,
w_degree = topenv(NS, V(NS)$nw)$label
)
return(V(graph[order(values, decreasing = TRUE)[1:n]]))
# Make a table showing topnv names and values for both metrics.
topnv <- function(graph, values, n=10) {
return(V(graph[order(values, decreasing = TRUE)[1:n]]))
}
tibble(
degree = topnv(NS, V(NS)$degree)$label,
w_degree = topenv(NS, V(NS)$nw)$label
)
tibble(
degree = topnv(NS, V(NS)$degree)$label,
)
tibble(
degree = topnv(NS, (NS)$degree)$label,
)
tibble(
degree = topnv(NS, degree(NS))$label,
)
topenv(NS, V(NS, V(NS)$i_degree))
topenv(NS, V(NS)$i_degree)$label)
topenv(NS, V(NS)$i_degree)$label
topenv(NS, V(NS)$i_degree)$labels
topenv(NS, V(NS)$i_degree)$label
topnv(NS, V(NS)$i_degree)$label
topnv(NS, V(NS)$i_degree)$labels
V(NS)[order(V(NS)$i_degree, decreasing = TRUE)]
V(NS)[order(V(NS)$i_degree, decreasing = TRUE)]$label
V(NS)[order(V(NS)$i_degree, decreasing = TRUE)][1:10]$label
tibble(
V(NS)[order(V(NS)$i_degree, decreasing = TRUE)][1:10]$label)
tibble(
degree = V(NS)[order(V(NS)$i_degree, decreasing = TRUE)][1:10]$label)
# The original distribution.
hist(E(NS)$weight, breaks=64)
# Edge weights converted to distances for path-based centralities
ew <- E(NS)$weight
nw <- (max(ew) + 1) - ew
class(E(NS)$weight)
E(NS)$distance       <- (max(E(NS)$weight) + 1) - E(NS)$weight
hist(as.numeric(E(NS)$distance, breaks=64))
# The original distribution.
hist(E(NS)$weight, breaks=64)
# Edge weights converted to distances for path-based centralities
E(NS)$distance       <- (max(E(NS)$weight) + 1) - E(NS)$weight
hist(as.numeric(E(NS)$distance, breaks=64))
tibble(
degree = V(NS)[order(V(NS)$i_degree, decreasing = TRUE)][1:10]$label,
weighted_degree = V(NS)[order(V(NS)$i_strength, decreasing = TRUE)][1:10]$label)
tibble(
degree = V(NS)[order(V(NS)$i_degree, decreasing = TRUE)][1:10]$label,
eigen = V(NS)[order(V(NS)$i_eigen_cent_u, decreasing = TRUE)][1:10]$label)
tibble(
degree = V(NS)$i_page_rank_w, decreasing = TRUE)][1:10]$label,
tibble(
degree = V(NS)[order(V(NS)$i_page_rank_w, decreasing = TRUE)][1:10]$label,
eigen = V(NS)[order(V(NS)$i_eigen_cent_u, decreasing = TRUE)][1:10]$label)
tibble(
degree = V(NS)[order(V(NS)$i_page_rank_u, decreasing = TRUE)][1:10]$label,
eigen = V(NS)[order(V(NS)$i_eigen_cent_u, decreasing = TRUE)][1:10]$label)
tibble(
degree = V(NS)[order(V(NS)$i_page_rank_u, decreasing = TRUE)][1:10]$label,
eigen = V(NS)[order(V(NS)$i_eigen_cent_u, decreasing = TRUE)][1:10]$label)
tibble(
degree = V(NS)[order(V(NS)$i_degree, decreasing = TRUE)][1:10]$label,
eigen = V(NS)[order(V(NS)$i_eigen_cent_u, decreasing = TRUE)][1:10]$label)
tibble(
page_rank = V(NS)[order(V(NS)$i_page_rank_u, decreasing = TRUE)][1:10]$label,
eigen = V(NS)[order(V(NS)$i_eigen_cent_u, decreasing = TRUE)][1:10]$label)
tibble(
page_rank = V(NS)[order(V(NS)$i_page_rank_u, decreasing = TRUE)][1:10]$label,
eigen = V(NS)[order(V(NS)$i_between_u, decreasing = TRUE)][1:10]$label)
tibble(
page_rank = V(NS)[order(V(NS)$i_page_rank_u, decreasing = TRUE)][1:10]$label,
between = V(NS)[order(V(NS)$i_between_u, decreasing = TRUE)][1:10]$label)
# Normalized Unweighted Betweenness
V(NS)$i_between_u    <- betweenness(NS, weights = NA)
# Normalized Weighted Betweenness using distances
V(NS)$i_between_w    <- betweenness(NS)
# Normalized Unweighted Closeness
V(NS)$i_closeness_u  <- closeness(NS, weights = NA)
# Normalized Weighted Closeness using distances
V(NS)$i_closeness_w  <- closeness(NS)
# Check that they are all there.
summary(NS)
# Normalized Unweighted Betweenness
V(NS)$i_between_u    <- betweenness(NS, weights = NA)
# Normalized Weighted Betweenness using distances
V(NS)$i_between_w    <- betweenness(NS)
# Normalized Unweighted Closeness
V(NS)$i_closeness_u  <- closeness(NS, weights = NA)
# Normalized Weighted Closeness using distances
V(NS)$i_closeness_w  <- closeness(NS)
# Check that they are all there.
summary(NS)
tibble(
page_rank = V(NS)[order(V(NS)$i_page_rank_u, decreasing = TRUE)][1:10]$label,
between = V(NS)[order(V(NS)$i_between_u, decreasing = TRUE)][1:10]$label)
tibble(
page_rank = V(NS)[order(V(NS)$i_page_rank_u, decreasing = TRUE)][1:10]$label,
between = V(NS)[order(V(NS)$i_between_u, decreasing = TRUE)][1:10]$label)
tibble(
page_rank = V(NS)[order(V(NS)$i_page_rank_u, decreasing = TRUE)][1:10]$label,
eigen = V(NS)[order(V(NS)$i_eigen_cent_u, decreasing = TRUE)][1:10]$label)
# Summarize topnv under the following metrics in a nice table:
# Degree
# Weighted degree
# Weighted page rank
# Weighted betweenness (using weights adjusted to be distances)
tibble(
degree = V(NS)[order(V(NS)$i_degree, decreasing = TRUE)][1:10]$label,
weighted_degree = V(NS)[order(V(NS)$i_strength, decreasing = TRUE)][1:10]$label,
page_rank = V(NS)[order(V(NS)$i_page_rank_u, decreasing = TRUE)][1:10]$label,
between = V(NS)[order(V(NS)$i_between_w, decreasing = TRUE)][1:10]$label) )
# Summarize topnv under the following metrics in a nice table:
# Degree
# Weighted degree
# Weighted page rank
# Weighted betweenness (using weights adjusted to be distances)
tibble(
degree = V(NS)[order(V(NS)$i_degree, decreasing = TRUE)][1:10]$label,
weighted_degree = V(NS)[order(V(NS)$i_strength, decreasing = TRUE)][1:10]$label,
page_rank = V(NS)[order(V(NS)$i_page_rank_u, decreasing = TRUE)][1:10]$label,
between = V(NS)[order(V(NS)$i_between_w, decreasing = TRUE)][1:10]$label)
HEP <- read_graph("Networks/cit-HepTh.gml", format="gml")
summary(HEP)
CH <- read_graph("Networks/comic-hero-network.graphml", format="graphml")
summary(CH)
HEP.gnm <- sample_gnm(vcount(HEP), ecount(HEP), directed=TRUE)
summary(HEP.gnm)
HEP.conf <- sample_degseq(degree(HEP, mode = "out"), degree(HEP, mode = "in"), method = 'simple')
# Replace this comment with your code to generate a configuration model
# with sample_degseq, specifying both out.deg and in.deg and using
# method 'simple'.
summary(HEP.config)
HEP.config <- sample_degseq(degree(HEP, mode = "out"), degree(HEP, mode = "in"), method = 'simple')
# Replace this comment with your code to generate a configuration model
# with sample_degseq, specifying both out.deg and in.deg and using
# method 'simple'.
summary(HEP.config)
HEP.config <- sample_degseq(degree(HEP, mode = "out"), degree(HEP, mode = "in"), method = 'simple')
summary(HEP.config)
# Replace this comment with computations of reciprocity and global
# transitivity, displayed in tabular form, such as:
#   Graph  reciprocity transitivity
#   HEP    #.######### #.##########
#   G(n,m) #.######### #.##########
#   Config #.######### #.##########
# Replace this comment with computations of reciprocity and global
# transitivity, displayed in tabular form, such as:
#   Graph  reciprocity transitivity
#   HEP    #.######### #.##########
#   G(n,m) #.######### #.##########
#   Config #.######### #.##########
models <- list(HEP, HEP.gnm, HEP.config)
tibble (
Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity(g, type = "global")))
# Replace this comment with computations of reciprocity and global
# transitivity, displayed in tabular form, such as:
#   Graph  reciprocity transitivity
#   HEP    #.######### #.##########
#   G(n,m) #.######### #.##########
#   Config #.######### #.##########
models <- list(HEP, HEP.gnm, HEP.config)
tibble (
Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity( type = "global")))
# Replace this comment with computations of reciprocity and global
# transitivity, displayed in tabular form, such as:
#   Graph  reciprocity transitivity
#   HEP    #.######### #.##########
#   G(n,m) #.######### #.##########
#   Config #.######### #.##########
models <- list(HEP, HEP.gnm, HEP.config)
tibble (
Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity(models, type = "global")))
# Replace this comment with computations of reciprocity and global
# transitivity, displayed in tabular form, such as:
#   Graph  reciprocity transitivity
#   HEP    #.######### #.##########
#   G(n,m) #.######### #.##########
#   Config #.######### #.##########
models <- list(HEP, HEP.gnm, HEP.config)
tibble (
Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity))
transitivity(HEP, type = "global")
tibble (
Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity))
transitivity(HEP.gnm, type = "global")
transitivity(HEP.config, type = "global")
tibble (
Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity))
models <- list(HEP, HEP.gnm, HEP.config)
tibble (
Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity))
reciprocity(CH)
transitivity(CH)
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# Optional, for including images of these types
library(jpeg)
library(png)
# Utilities
source("Utility/topnv.R")
NS <- read.graph("Networks/netscience.graphml", format="graphml")
summary(NS)
# Unweighted Degree
V(NS)$i_degree       <- degree(NS)
# Weighted Degree
V(NS)$i_strength     <- strength(NS)
# Unweighted Eigenvector Centrality
V(NS)$i_eigen_cent_u <- eigen_centrality(NS, directed = FALSE)$vector
# Weighted Eigenvector Centrality
V(NS)$i_eigen_cent_w <- eigen_centrality(NS)$vector
# Unweighted Page Rank
V(NS)$i_page_rank_u  <- page_rank(NS, weights = NA)$vector
# Weighted Page Rank
V(NS)$i_page_rank_w  <- page_rank(NS)$vector
# Check that they are all there and none came out v/x
head(V(NS)$i_eigen_cent_u)
head(V(NS)$i_eigen_cent_w)
tail(V(NS)$i_eigen_cent_u)
tail(V(NS)$i_eigen_cent_w)
max(V(NS)$i_eigen_cent_u)
max(V(NS)$i_eigen_cent_w)
summary(NS)
# The original distribution.
hist(E(NS)$weight, breaks=64)
# Edge weights converted to distances for path-based centralities
E(NS)$distance       <- (max(E(NS)$weight) + 1) - E(NS)$weight
hist(as.numeric(E(NS)$distance, breaks=64))
# Normalized Unweighted Betweenness
V(NS)$i_between_u    <- betweenness(NS, weights = NA)
# Normalized Weighted Betweenness using distances
V(NS)$i_between_w    <- betweenness(NS)
# Normalized Unweighted Closeness
V(NS)$i_closeness_u  <- closeness(NS, weights = NA)
# Normalized Weighted Closeness using distances
V(NS)$i_closeness_w  <- closeness(NS)
# Check that they are all there.
summary(NS)
# Unweighted Degree
V(NS)$i_degree       <- degree(NS)
# Weighted Degree
V(NS)$i_strength     <- strength(NS)
# Unweighted Eigenvector Centrality
V(NS)$i_eigen_cent_u <- eigen_centrality(NS, directed = FALSE)$vector
# Weighted Eigenvector Centrality
V(NS)$i_eigen_cent_w <- eigen_centrality(NS)$vector
# Unweighted Page Rank
V(NS)$i_page_rank_u  <- page_rank(NS, weights = NA)$vector
# Weighted Page Rank
V(NS)$i_page_rank_w  <- page_rank(NS)$vector
# Check that they are all there and none came out v/x
summary(NS)
# Make a table showing topnv names and values for both metrics.
tibble(
degree = V(NS)[order(V(NS)$i_degree, decreasing = TRUE)][1:10]$label,
weighted_degree = V(NS)[order(V(NS)$i_strength, decreasing = TRUE)][1:10]$label)
library(igraph)
setwd("/Users/frederickstraub/GitHub/ICS422/R-Files") # Set to yours
NS <- read_graph("Networks/netscience.graphml", format="graphml")
summary(NS)
TI <- read_graph("Networks/TI-Chats-Week-of-060401.graphml", format="graphml")
summary(TI)
library(igraph)
library(tibble)
setwd("/Users/frederickstraub/GitHub/ICS422/R-Files") # Set to yours
TI <- read.graph("Networks/TI-Chats-Week-of-060401.graphml", format="graphml")
?communities
K <- make_graph("Zachary")
summary(K)
?cluster_optimal
K.opt <- cluster_optimal(K)
names(K.opt) # to see what information it returns
membership(K.opt)
modularity(K.opt)
modularity(K, membership(K.opt)) # same result
K.layout <- layout_with_fr(K)
plot_karate <- function(comm, title){
plot(comm, K, layout=K.layout,
main=paste0(title,
": M = ", round(modularity(comm), 4),
", # = ", length(comm)))
}
plot_karate(K.opt, "Optimal")
vcount(NS)
2^vcount(NS)
2^vcount(TI)
?cluster_edge_betweenness
K.eb <- cluster_edge_betweenness(K)
is_hierarchical(K.eb)
names(K.eb)
plot_karate(K.eb, "Edge Betweenness")
?cluster_fast_greedy
K.fg <- cluster_fast_greedy(K)
names(K.fg)
plot_karate(K.fg, "Fast Greedy")
?cluster_louvain
K.louvain <- cluster_louvain(K)
names(K.louvain)
modularity(K.louvain)
K.louvain$modularity
K.louvain$membership
K.louvain$memberships
plot_karate(K.louvain, "Louvain")
plot_karate(K.opt, "Optimal") # To compare
?cluster_infomap
K.infomap <- cluster_infomap(K)
names(K.infomap)
K.infomap$codelength # what it is optimizing
plot_karate(K.infomap, "InfoMap")
?cluster_spinglass
K.sg <- cluster_spinglass(K)
plot_karate(K.sg, "Spinglass") # !
?cluster_walktrap
K.wt <- cluster_walktrap(K)
plot_karate(K.wt, "Walktrap")
NS.maxcliques <- max_cliques(NS)
table(sapply(NS.maxcliques, length))
NS.components <- components(NS)
attributes(NS.components)
table(NS.components$csize)
modularity(NS, NS.components$membership)
?cluster_louvain
NS.louvain <- cluster_louvain(NS)
NS.louvain$modularity
modularity(NS, NS.components$membership) # for comparison
modularity(NS.louvain)
length(NS.louvain)
table(sizes(NS.louvain))
table(NS.components$csize)
V(NS)$comm_louvain <- membership(NS.louvain)
summary(NS)
?cluster_infomap
NS.infomap <- cluster_infomap(NS)
modularity(NS.infomap) # InfoMap
modularity(NS.louvain) # Louvain
length(NS.infomap) # InfoMap
length(NS.louvain) # Louvain
V(NS)$comm_infomap <- membership(NS.infomap)
summary(NS)
