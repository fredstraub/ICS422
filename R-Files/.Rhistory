Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity(models, type = "global")))
# Replace this comment with computations of reciprocity and global
# transitivity, displayed in tabular form, such as:
#   Graph  reciprocity transitivity
#   HEP    #.######### #.##########
#   G(n,m) #.######### #.##########
#   Config #.######### #.##########
models <- list(HEP, HEP.gnm, HEP.config)
tibble (
Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity))
transitivity(HEP, type = "global")
tibble (
Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity))
transitivity(HEP.gnm, type = "global")
transitivity(HEP.config, type = "global")
tibble (
Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity))
models <- list(HEP, HEP.gnm, HEP.config)
tibble (
Graph  = c("HEP", "G(n,m)", "Config"),
reciprocity = sapply(models, reciprocity),
transitivity = sapply(models, transitivity))
reciprocity(CH)
transitivity(CH)
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# Optional, for including images of these types
library(jpeg)
library(png)
# Utilities
source("Utility/topnv.R")
NS <- read.graph("Networks/netscience.graphml", format="graphml")
summary(NS)
# Unweighted Degree
V(NS)$i_degree       <- degree(NS)
# Weighted Degree
V(NS)$i_strength     <- strength(NS)
# Unweighted Eigenvector Centrality
V(NS)$i_eigen_cent_u <- eigen_centrality(NS, directed = FALSE)$vector
# Weighted Eigenvector Centrality
V(NS)$i_eigen_cent_w <- eigen_centrality(NS)$vector
# Unweighted Page Rank
V(NS)$i_page_rank_u  <- page_rank(NS, weights = NA)$vector
# Weighted Page Rank
V(NS)$i_page_rank_w  <- page_rank(NS)$vector
# Check that they are all there and none came out v/x
head(V(NS)$i_eigen_cent_u)
head(V(NS)$i_eigen_cent_w)
tail(V(NS)$i_eigen_cent_u)
tail(V(NS)$i_eigen_cent_w)
max(V(NS)$i_eigen_cent_u)
max(V(NS)$i_eigen_cent_w)
summary(NS)
# The original distribution.
hist(E(NS)$weight, breaks=64)
# Edge weights converted to distances for path-based centralities
E(NS)$distance       <- (max(E(NS)$weight) + 1) - E(NS)$weight
hist(as.numeric(E(NS)$distance, breaks=64))
# Normalized Unweighted Betweenness
V(NS)$i_between_u    <- betweenness(NS, weights = NA)
# Normalized Weighted Betweenness using distances
V(NS)$i_between_w    <- betweenness(NS)
# Normalized Unweighted Closeness
V(NS)$i_closeness_u  <- closeness(NS, weights = NA)
# Normalized Weighted Closeness using distances
V(NS)$i_closeness_w  <- closeness(NS)
# Check that they are all there.
summary(NS)
# Unweighted Degree
V(NS)$i_degree       <- degree(NS)
# Weighted Degree
V(NS)$i_strength     <- strength(NS)
# Unweighted Eigenvector Centrality
V(NS)$i_eigen_cent_u <- eigen_centrality(NS, directed = FALSE)$vector
# Weighted Eigenvector Centrality
V(NS)$i_eigen_cent_w <- eigen_centrality(NS)$vector
# Unweighted Page Rank
V(NS)$i_page_rank_u  <- page_rank(NS, weights = NA)$vector
# Weighted Page Rank
V(NS)$i_page_rank_w  <- page_rank(NS)$vector
# Check that they are all there and none came out v/x
summary(NS)
# Make a table showing topnv names and values for both metrics.
tibble(
degree = V(NS)[order(V(NS)$i_degree, decreasing = TRUE)][1:10]$label,
weighted_degree = V(NS)[order(V(NS)$i_strength, decreasing = TRUE)][1:10]$label)
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# Optional, for including images of these types
library(jpeg)
library(png)
# Utilities may be added here.
source("Utility/degree_domain.R")
source("Utility/nonzero_degree_distribution.R")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("PS_v1.graphml")
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# Optional, for including images of these types
library(jpeg)
library(png)
# Utilities may be added here.
source("Utility/degree_domain.R")
source("Utility/nonzero_degree_distribution.R")
PS_v1 <- read_graph("PS_v1.graphml")
# PS_v1 <- read_graph(_________)
# If you don't have have 242 vertices and 11438 edges, or you see
#   r (v/n), g (v/n), b (v/n), x (v/n), y (v/n), size (v/n)
# go back to Gephi and fix it!
# summary(PS_v1)
# PS_v1 <- read_graph(_________)
# If you don't have have 242 vertices and 11438 edges, or you see
#   r (v/n), g (v/n), b (v/n), x (v/n), y (v/n), size (v/n)
# go back to Gephi and fix it!
summary(PS_v1)
PS_v1 <- read_graph("PS_v1.graphml")
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# Optional, for including images of these types
library(jpeg)
library(png)
# Utilities may be added here.
source("Utility/degree_domain.R")
source("Utility/nonzero_degree_distribution.R")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PSv1.graphml")
PS_v1 <- read_graph("Networks/PSv1.graphml")
PS_v1 <- read_graph("Networks/PSv1.graphml")
PS_v1 <- read_graph("Networks/PSv1.graphml")
PS_v1 <- read_graph("Networks/PSv1.graphml")
PS_v1 <- read_graph("Networks/PSv1.graphml")
PS_v1 <- read_graph("Networks/PSv1.graphml")
PS_v1 <- read_graph("Networks/aidsblog.graphml")
PS_v1 <- read_graph("Networks/aidsblog.graphml")
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# Optional, for including images of these types
library(jpeg)
library(png)
# Utilities may be added here.
setwd("/Users/frederickstraub/Documents/College/UHM/ICS-422/Assignment/Analysis6")
source("Utility/degree_domain.R")
source("Utility/nonzero_degree_distribution.R")
PS_v1 <- read_graph("Networks/PS_v1.graphml")
PS_v1 <- read_graph("Networks/PSv1.graphml")
PS_v1 <- read_graph("Networks/PSv1.graphml")
PS_v1 <- read_graph("Networks/PSv1.graphml")
PS_v1 <- read_graph("Networks/PSv1.graphml")
PS_v1 <- read_graph("Networks/PSv1.gml")
PS_v1 <- read_graph("/Users/frederickstraub/Documents/College/UHM/ICS-422/Assignment/Analysis6/Networks/PSv1.gml")
PS_v1 <- read_graph("/Users/frederickstraub/Documents/College/UHM/ICS-422/Assignment/Analysis6/Networks/PSv1.graphml")
PS_v1 <- read_graph("/Users/frederickstraub/Documents/College/UHM/ICS-422/Assignment/Analysis6/Networks/PSv1.graphml")
PS_v1 <- read_graph("/Users/frederickstraub/Documents/College/UHM/ICS-422/Assignment/Analysis6/Networks/PSv1.graphml", format="graphml")
# If you don't have have 242 vertices and 11438 edges, or you see
#   r (v/n), g (v/n), b (v/n), x (v/n), y (v/n), size (v/n)
# go back to Gephi and fix it!
summary(PS_v1)
print(paste("Before simplify: max count =", max(E(PS_v1)$count),
"max duration =", max(E(PS_v1)$duration)),
quote=FALSE)
#
# # Using version numbers to enable comparison if needed for debugging.
#
# PS_v2 <- simplify(__________________________)
#
# print(paste("After simplify: max count =", max(E(PS_v2)$count),
#             "max duration =", max(E(PS_v2)$duration)),
#       quote=FALSE)
#
# # If you don't have have 242 vertices and 8316 edges, with
# # max count = 278 max duration = 15280, stop and fix it!
# summary(PS_v2)
#
# # Using version numbers to enable comparison if needed for debugging.
#
PS_v2 <- simplify(edge.attr.comb = sum(E(PS_v1)$duration), sum(E(PS_v1)$count), sum(E(PS_v1)$weight))
#
# # Using version numbers to enable comparison if needed for debugging.
#
PS_v2 <- simplify(edge.attr.comb = sum(E(PS_v1)$duration), sum(E(PS_v1)$count))
#
# # Using version numbers to enable comparison if needed for debugging.
#
?simplify
PS_v2 <- simplify(PS_v1, edge.attr.comb = list(durration="sum", count="sum", weight="sum"))
#
print(paste("After simplify: max count =", max(E(PS_v2)$count),
"max duration =", max(E(PS_v2)$duration)),
quote=FALSE)
PS_v2 <- simplify(PS_v1, edge.attr.comb = list(durration="sum", count="sum", weight="sum"))
#
print(paste("After simplify: max count =", max(E(PS_v2)$count),
"max duration =", max(E(PS_v2)$duration)),
quote=FALSE)
print(paste("Before simplify: max count =", max(E(PS_v1)$count),
"max duration =", max(E(PS_v1)$duration)),
quote=FALSE)
PS_v2 <- simplify(PS_v1, edge.attr.comb = list(durration="sum", count="sum", weight="sum"))
#
print(paste("After simplify: max count =", max(E(PS_v2)$count),
"max duration =", max(E(PS_v2)$duration)),
quote=FALSE)
print(paste("Before simplify: max count =", max(E(PS_v1)$count),
"max duration =", max(E(PS_v1)$duration)),
quote=FALSE)
PS_v2 <- simplify(PS_v1, edge.attr.comb = list(durration="sum", count="sum", weight="sum", "ignore"))
#
print(paste("After simplify: max count =", max(E(PS_v2)$count),
"max duration =", max(E(PS_v2)$duration)),
quote=FALSE)
PS_v2 <- simplify(PS_v1, edge.attr.comb = list(duration="sum", count="sum", weight="sum", "ignore"))
#
print(paste("After simplify: max count =", max(E(PS_v2)$count),
"max duration =", max(E(PS_v2)$duration)),
quote=FALSE)
print(paste("Before simplify: max count =", max(E(PS_v1)$count),
"max duration =", max(E(PS_v1)$duration)),
quote=FALSE)
PS_v2 <- simplify(PS_v1, edge.attr.comb = list(duration="sum", count="sum", weight="sum", "ignore"))
#
print(paste("After simplify: max count =", max(E(PS_v2)$count),
"max duration =", max(E(PS_v2)$duration)),
quote=FALSE)
#
# # If you don't have have 242 vertices and 8316 edges, with
# # max count = 278 max duration = 15280, stop and fix it!
summary(PS_v2)
table(V(PSF)$classname)
table(V(PS_v2)$classname)
PS_v3 <- delete_vertices(V(PS_v2)$classname == Teachers )
PS_v3 <- delete_vertices(V(PS_v2)$classname == "Teachers" )
?delete_vertices
PS_v3 <- delete_vertices(PS_v2, $classname == "Teachers" )
PS_v3 <- delete_vertices(PS_v2, classname == "Teachers" )
PS_v3 <- delete_vertices(PS_v2, $classname == "Teachers" )
PS_v3 <- delete_vertices(V(PS_v2)[V(PS_v2)$classname == "Teachers"] )
PS_v3 <- delete_vertices([V(PS_v2)$classname == "Teachers"] )
PS_v3 <- delete_vertices(V(PS_v2)$classname == "Teachers")
PS_v3 <- delete_vertices(V(PS_v2)$classname, value = "Teachers")
PS_v3 <- delete_vertices(PS_v2, classname == "Teachers")
PS_v3 <- delete_vertices(PS_v2, $classname == "Teachers")
PS_v3 <- delete_vertices(V(PS_v2)$classname == "Teachers")
PS_v3 <- delete_vertices(V(PS_v2)$classname == Teachers)
PS_v3 <- delete_vertices(V(PS_v2)$classname == 'Teachers')
PS_v3 <- delete_vertices(V(graph)[V(graph)$classname == Teachers])
PS_v3 <- delete_vertices(V(PS_v2)[V(PS_v2)$classname == Teachers])
PS_v3 <- delete_vertices(V(PS_v2)[V(PS_v2)$classname == "Teachers"])
PS_v3 <- delete_vertices(PS_v2, [V(PS_v2)$classname == "Teachers"])
PS_v3 <- delete_vertices(PS_v2, V(PS_v2)$classname == "Teachers")
# # Should now have 232 vertices, 7855 edges.
summary(PS_v3)
table(V(PS_v3)$classname)
table(V(PS_v3)$gender)
interact <- table(count=E(PS_v3)$count, duration=E(PS_v3)$duration)
interact <- table(count=E(PS_v3)$count, duration=E(PS_v3)$duration)
interact[1:10,1:12]
PSF <- delete_edges(PS_v3, E(PS_v3)$duration < 60)
interact <- table(count=E(PS_v3)$count, duration=E(PS_v3)$duration)
interact[1:10,1:12]
PSF <- delete_edges(PS_v3, duration < 60)
PSF <- delete_edges(PS_v3, $duration < 60)
PSF <- delete_edges(PS_v3, E(PS_v3)$duration < 60)
PSF <- delete_edges(PS_v3, E(PS_v3)$duration < 60)
PSF <- delete_edges(PS_v3, E(PS_v3)$duration <= 40)
PSF <- PS_v3
PSF <- delete_edges(PS_v3, E(PS_v3)$duration <= 40)
PSF <- delete_edges(PS_v3, E(PS_v3)$duration <= 40)
PSF <- delete_edges(PS_v3, E(PS_v3)$duration == 20 )
# # Expecting 232 vertices 3312 edges
summary(PSF)
# # Expecting max count 278 max duration 15280
print(paste("After filtering: max count =", max(E(PSF)$count),
"max duration =", max(E(PSF)$duration)),
quote=FALSE)
PSF <- delete_edges(PS_v3, E(PS_v3)$duration == 20 )
PSF <- delete_edges(PS_v3, E(PS_v3)$duration <60 )
PSF <- delete_edges(PS_v3, E(PS_v3)$duration < "60" )
PSF <- delete_edges(PS_v3, E(PS_v3)$duration < 60 )
summary(PSF)
summary(PSF)
PSF <- delete_edges(PS_v3, E(PS_v3)$duration < 60 )
#PSF <- delete_edges(PS_v3, E(PS_v3)$duration < 60 )
PSF <- delete_edges(PS_v3, E(PS_v3)$duration <= E(PS_v3)$count*20)
#PSF <- delete_edges(PS_v3, E(PS_v3)$duration < 60 )
PSF <- delete_edges(PS_v3, E(PS_v3)$duration <= E(PS_v3)$count*20)
PSF <- delete_edges(PS_v3, E(PS_v3)$duration < 60 )
require("knitr")
opts_chunk$set(echo = TRUE)
library(igraph)
library(tibble)
# Optional, for including images of these types
library(jpeg)
library(png)
# Utilities may be added here.
setwd("/Users/frederickstraub/Documents/College/UHM/ICS-422/Assignment/Analysis6")
source("Utility/degree_domain.R")
source("Utility/nonzero_degree_distribution.R")
PS_v1 <- read_graph("/Users/frederickstraub/Documents/College/UHM/ICS-422/Assignment/Analysis6/Networks/PSv1.graphml", format="graphml")
# If you don't have have 242 vertices and 11438 edges, or you see
#   r (v/n), g (v/n), b (v/n), x (v/n), y (v/n), size (v/n)
# go back to Gephi and fix it!
summary(PS_v1)
print(paste("Before simplify: max count =", max(E(PS_v1)$count),
"max duration =", max(E(PS_v1)$duration)),
quote=FALSE)
#
# # Using version numbers to enable comparison if needed for debugging.
#
PS_v2 <- simplify(PS_v1, edge.attr.comb = list(duration="sum", count="sum", weight="sum", "ignore"))
#
print(paste("After simplify: max count =", max(E(PS_v2)$count),
"max duration =", max(E(PS_v2)$duration)),
quote=FALSE)
#
# # If you don't have have 242 vertices and 8316 edges, with
# # max count = 278 max duration = 15280, stop and fix it!
summary(PS_v2)
table(V(PS_v2)$classname)
PS_v3 <- delete_vertices(PS_v2, V(PS_v2)$classname == "Teachers")
# # Should now have 232 vertices, 7855 edges.
summary(PS_v3)
table(V(PS_v3)$classname)
table(V(PS_v3)$gender)
interact <- table(count=E(PS_v3)$count, duration=E(PS_v3)$duration)
interact[1:10,1:12]
summary(PSF)
PSF <- delete_edges(PS_v3, E(PS_v3)$duration < 60 )
PSF <- delete_edges(PS_v3, E(PS_v3)$duration < 60 )
PSF <- delete_edges(which(PS_v3, E(PS_v3)$duration < 60 ))
PSF <- which(delete_edges(PS_v3, E(PS_v3)$duration < 60 ))
PSF <- delete_edges(PS_v3, which((PS_v3)$duration < 60 ))
PSF <- delete_edges(PS_v3, which(E(PS_v3)$duration <= E(PS_v3)$count*20))
PSF <- delete_edges(PS_v3, which(E(PS_v3)$duration < 60 ))
PSF <- delete_edges(PS_v3, which(E(PS_v3)$duration <= E(PS_v3)$count*20))
PSF$name <- "Filtered Primary School Contacts"
# # Expecting 232 vertices 3312 edges
summary(PSF)
# # Expecting max count 278 max duration 15280
print(paste("After filtering: max count =", max(E(PSF)$count),
"max duration =", max(E(PSF)$duration)),
quote=FALSE)
table(count=E(PSF)$count, duration=E(PSF)$duration)[1:10,1:12]
E(PSF)$"id"
#
# # Using version numbers to enable comparison if needed for debugging.
#
PS_v2 <- simplify(PS_v1, edge.attr.comb = list(duration="sum", count="sum", weight="sum", id="first", "ignore"))
#
print(paste("After simplify: max count =", max(E(PS_v2)$count),
"max duration =", max(E(PS_v2)$duration)),
quote=FALSE)
print(paste("Before simplify: max count =", max(E(PS_v1)$count),
"max duration =", max(E(PS_v1)$duration)),
quote=FALSE)
#
# # Using version numbers to enable comparison if needed for debugging.
#
PS_v2 <- simplify(PS_v1, edge.attr.comb = list(duration="sum", count="sum", weight="sum", id="first", "ignore"))
#
print(paste("After simplify: max count =", max(E(PS_v2)$count),
"max duration =", max(E(PS_v2)$duration)),
quote=FALSE)
#
# # If you don't have have 242 vertices and 8316 edges, with
# # max count = 278 max duration = 15280, stop and fix it!
summary(PS_v2)
table(V(PS_v2)$classname)
PS_v3 <- delete_vertices(PS_v2, V(PS_v2)$classname == "Teachers")
# # Should now have 232 vertices, 7855 edges.
summary(PS_v3)
table(V(PS_v3)$classname)
table(V(PS_v3)$gender)
interact <- table(count=E(PS_v3)$count, duration=E(PS_v3)$duration)
interact[1:10,1:12]
PSF <- delete_edges(PS_v3, which(E(PS_v3)$duration < 60 ))
PSF <- delete_edges(PS_v3, which(E(PS_v3)$duration <= E(PS_v3)$count*20))
PSF$name <- "Filtered Primary School Contacts"
# # Expecting 232 vertices 3312 edges
summary(PSF)
# # Expecting max count 278 max duration 15280
print(paste("After filtering: max count =", max(E(PSF)$count),
"max duration =", max(E(PSF)$duration)),
quote=FALSE)
table(count=E(PSF)$count, duration=E(PSF)$duration)[1:10,1:12]
E(PSF)$"id"
V(PSF)$grade <- _________________________________
V(PSF)$grade <- substr(V(PSF)$classname, 1,1)
table(V(PSF)$grade)
PSF_gnm  <- sample_gnm(232, 3312)
summary(PSF_gnm)
# # Use niter = ecount(PSF)*1000 for sufficient rewiring
PSF_rrw  <- rewire(PSF, with = keeping_degseq(niter = ecount(PSF)*1000))
PSF_rrw$name <- "Rewired Primary School Contacts"
summary(PSF_rrw)
######################################################################
# Overlapping Community Detection
# Class Activity
# Dan Suthers, April 6, 2017
# Nov 14, 2019 DS: cleaned up for fall 2019 class
# Apr  6 2021 DS: Updates for ICS 422/622 Spring 2021
#
######################################################################
# Setup
library(igraph)
library(linkcomm)
setwd("/Users/frederickstraub/GitHub/ICS422/R-Files") # Set to yours
TI <- read.graph("Networks/TI-Chats-Week-of-060401.graphml", format="graphml")
summary(TI)
######################################################################
# Make edgelist representation
TI.edges <- as_edgelist(TI)
TI.edges <-
head(TI.edges)
TI.edges <- cbind(TI.edges, E(TI)$weight)
head(TI.edges)
# Compute and check link communities
TI.lc <- getLinkCommunities(TI.edges, hcmethod="average", plot=FALSE)
print(TI.lc)
######################################################################
# Make edgelist representation
TI.edges <- as_edgelist(TI)
TI.edges <- cbind(TI.edges, E(TI)$weight)
head(TI.edges)
# Compute and check link communities
TI.lc <- getLinkCommunities(TI.edges, hcmethod="average", plot=FALSE)
print(TI.lc)
######################################################################
# reify_link_communities
reify_link_communities(TI)
######################################################################
# reify_link_communities
comm_label(TI)
######################################################################
# reify_link_communities
reify_link_communities(TI, TI.lc)
######################################################################
# reify_link_communities
comm_label(TI, TI.lc)
######################################################################
library(igraph)
library(linkcomm)
# Community labels will be constructed from IDs to indicate
# that they are communities.
#
comm_label <- function (id) {return(paste0("COMM_", id))}
# Given a graph g and a legal link community object lc for
# that graph, returns a copy of the graph with communities
# added as vertices. We don't compute the link community
# within this function as we want the user to retain full
# control of that computation through its various parameters.
#
reify_link_communities <- function(g, lc) {
#  Mark existing vertices as not being community nodes.
V(g)$comm_p <- FALSE
# Names of community vertices for each cluster.
comm_names <- as.character(lapply(unique(lc$nodeclusters$cluster),
comm_label))
# Create a community vertex for each cluster, using the above
# labels. Add these vertices all at once for one graph copy.
g <- add_vertices(g,
length(comm_names),
label = comm_names,
comm_p = TRUE)
# Get list of vertices from the original graph that are in link
# communities (some may not be, so we use $node, not V(g)).
node_ids <- as.numeric(lc$nodeclusters$node)
# Make corresponding list of communities identified by label.
comm_labels <- as.vector(vapply(lc$nodeclusters$cluster,
comm_label,
character(1)))
# Add edges from original nodes to community vertices all at once.
# add_edges wants a list of alternating source and target vertices,
# that is, pairs of node + community vertices. We use an anonymous
# function to make pairs, and then flatten the list. Need to use
# 'which' to map from string comm_labels to actual node IDs in V(g).
g <- add_edges(g,
unlist(lapply(1:length(node_ids),
function(i) {
c(node_ids[i],
which(V(g)$label == comm_labels[i]))
})))
return(g)
}
# Compute and check link communities
TI.lc <- getLinkCommunities(TI.edges, hcmethod="average",directed = TRUE, plot=FALSE)
print(TI.lc)
